/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/footable.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/footable.js":
/*!************************!*\
  !*** ./js/footable.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n* FooTable v3 - FooTable is a jQuery plugin that aims to make HTML tables on smaller devices look awesome.\n* @version 3.1.6\n* @link http://fooplugins.com\n* @copyright Steven Usher & Brad Vincent 2015\n* @license Released under the GPLv3 license.\n*/\n(function($, F){\n\t// add in console we use in case it's missing\n\twindow.console = window.console || { log:function(){}, error:function(){} };\n\n\t/**\n\t * The jQuery plugin initializer.\n\t * @function jQuery.fn.footable\n\t * @param {(object|FooTable.Defaults)} [options] - The options to initialize the plugin with.\n\t * @param {function} [ready] - A callback function to execute for each initialized plugin.\n\t * @returns {jQuery}\n\t */\n\t$.fn.footable = function (options, ready) {\n\t\toptions = options || {};\n\t\t// make sure we only work with tables\n\t\treturn this.filter('table').each(function (i, tbl) {\n\t\t\tF.init(tbl, options, ready);\n\t\t});\n\t};\n\n\tvar debug_defaults = {\n\t\tevents: []\n\t};\n\tF.__debug__ = JSON.parse(localStorage.getItem('footable_debug')) || false;\n\tF.__debug_options__ = JSON.parse(localStorage.getItem('footable_debug_options')) || debug_defaults;\n\n\t/**\n\t * Gets or sets the internal debug variable which enables some additional logging to the console.\n\t * When enabled this value is stored in the localStorage so it can persist across page reloads.\n\t * @param {boolean} value - Whether or not to enable additional logging.\n\t * @param {object} [options] - Any debug specific options.\n\t * @returns {(boolean|undefined)}\n\t */\n\tF.debug = function(value, options){\n\t\tif (!F.is.boolean(value)) return F.__debug__;\n\t\tF.__debug__ = value;\n\t\tif (F.__debug__){\n\t\t\tlocalStorage.setItem('footable_debug', JSON.stringify(F.__debug__));\n\t\t\tF.__debug_options__ = $.extend(true, {}, debug_defaults, options || {});\n\t\t\tif (F.is.hash(options)){\n\t\t\t\tlocalStorage.setItem('footable_debug_options', JSON.stringify(F.__debug_options__));\n\t\t\t}\n\t\t} else {\n\t\t\tlocalStorage.removeItem('footable_debug');\n\t\t\tlocalStorage.removeItem('footable_debug_options');\n\t\t}\n\t};\n\n\t/**\n\t * Gets the FooTable instance of the supplied table if one exists.\n\t * @param {(jQuery|jQuery.selector|HTMLTableElement)} table - The jQuery table object, selector or the HTMLTableElement to retrieve FooTable from.\n\t * @returns {(FooTable.Table|undefined)}\n\t */\n\tF.get = function(table){\n\t\treturn $(table).first().data('__FooTable__');\n\t};\n\n\t/**\n\t * Initializes a new instance of FooTable on the supplied table.\n\t * @param {(jQuery|jQuery.selector|HTMLTableElement)} table - The jQuery table object, selector or the HTMLTableElement to initialize FooTable on.\n\t * @param {object} options - The options to initialize FooTable with.\n\t * @param {function} [ready] - A callback function to execute once the plugin is initialized.\n\t * @returns {FooTable.Table}\n\t */\n\tF.init = function(table, options, ready){\n\t\tvar ft = F.get(table);\n\t\tif (ft instanceof F.Table) ft.destroy();\n\t\treturn new F.Table(table, options, ready);\n\t};\n\n\t/**\n\t * Gets the FooTable.Row instance for the supplied element.\n\t * @param {(jQuery|jQuery.selector|HTMLTableElement)} element - A jQuery object, selector or the HTMLElement of an element to retrieve the FooTable.Row for.\n\t * @returns {FooTable.Row}\n\t */\n\tF.getRow = function(element){\n\t\t// to get the FooTable.Row object simply walk up the DOM, find the TR and grab the __FooTableRow__ data value\n\t\tvar $row = $(element).closest('tr');\n\t\t// if this is a detail row get the previous row in the table to get the main TR element\n\t\tif ($row.hasClass('footable-detail-row')){\n\t\t\t$row = $row.prev();\n\t\t}\n\t\t// grab the row object\n\t\treturn $row.data('__FooTableRow__');\n\t};\n\n\t// The below are external type definitions mainly used as pointers to jQuery docs for important information\n\t/**\n\t * jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API\n\t * that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript.\n\t * @name jQuery\n\t * @constructor\n\t * @returns {jQuery}\n\t * @see {@link http://api.jquery.com/}\n\t */\n\n\t/**\n\t * This object provides a subset of the methods of the Deferred object (then, done, fail, always, pipe, and state) to prevent users from changing the state of the Deferred.\n\t * @typedef {object} jQuery.Promise\n\t * @see {@link http://api.jquery.com/Types/#Promise}\n\t */\n\n\t/**\n\t * As of jQuery 1.5, the Deferred object provides a way to register multiple callbacks into self-managed callback queues, invoke callback queues as appropriate,\n\t * and relay the success or failure state of any synchronous or asynchronous function.\n\t * @typedef {object} jQuery.Deferred\n\t * @see {@link http://api.jquery.com/Types/#Deferred}\n\t */\n\n\t/**\n\t * jQuery's event system normalizes the event object according to W3C standards. The event object is guaranteed to be passed to the event handler. Most properties from\n\t * the original event are copied over and normalized to the new event object.\n\t * @typedef {object} jQuery.Event\n\t * @see {@link http://api.jquery.com/category/events/event-object/}\n\t */\n\n\t/**\n\t * Provides a way to execute callback functions based on one or more objects, usually Deferred objects that represent asynchronous events.\n\t * @memberof jQuery\n\t * @function when\n\t * @param {...jQuery.Deferred} deferreds - Any number of deferred objects to wait for.\n\t * @returns {jQuery.Promise}\n\t * @see {@link http://api.jquery.com/jQuery.when/}\n\t */\n\n\t/**\n\t * The jQuery.fn namespace used to register plugins with jQuery.\n\t * @memberof jQuery\n\t * @namespace fn\n\t * @see {@link http://learn.jquery.com/plugins/basic-plugin-creation/}\n\t */\n})(\n\tjQuery,\n\t/**\n\t * The core FooTable namespace containing all the plugin code.\n\t * @namespace\n\t */\n\tFooTable = window.FooTable || {}\n);\n(function(F){\n\tvar returnTrue = function(){ return true; };\n\n\t/**\n\t * This namespace contains commonly used array utility methods.\n\t * @namespace {object} FooTable.arr\n\t */\n\tF.arr = {};\n\n\t/**\n\t * Iterates over each item in the supplied array and performs the supplied function passing in the current item as the first argument.\n\t * @memberof FooTable.arr\n\t * @function each\n\t * @param {Array} array - The array to iterate\n\t * @param {function} func - The function to execute for each item. The first argument supplied to this function is the current item and the second is the current index.\n\t */\n\tF.arr.each = function (array, func) {\n\t\tif (!F.is.array(array) || !F.is.fn(func)) return;\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tif (func(array[i], i) === false) break;\n\t\t}\n\t};\n\n\t/**\n\t * Get all items in the supplied array that optionally matches the supplied where function. If no items are found an empty array is returned.\n\t * @memberof FooTable.arr\n\t * @function get\n\t * @param {Array} array - The array to get items from.\n\t * @param {function} where - This function must return a boolean value, true includes the item in the result array.\n\t * @returns {Array}\n\t */\n\tF.arr.get = function (array, where) {\n\t\tvar result = [];\n\t\tif (!F.is.array(array)) return result;\n\t\tif (!F.is.fn(where)) return array;\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tif (where(array[i], i)) result.push(array[i]);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Get a boolean value indicating if any item exists in the supplied array that optionally matches the supplied where function.\n\t * @memberof FooTable.arr\n\t * @function any\n\t * @param {Array} array - The array to check.\n\t * @param {function} [where] - [Optional] This function must return a boolean value, true indicates that the current item is a valid match.\n\t * @returns {boolean}\n\t */\n\tF.arr.any = function (array, where) {\n\t\tif (!F.is.array(array)) return false;\n\t\twhere = F.is.fn(where) ? where : returnTrue;\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tif (where(array[i], i)) return true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Checks if the supplied value exists in the array.\n\t * @memberof FooTable.arr\n\t * @function contains\n\t * @param {Array} array - The array to check.\n\t * @param {*} value - The value to check for.\n\t * @returns {boolean}\n\t */\n\tF.arr.contains = function(array, value){\n\t\tif (!F.is.array(array) || F.is.undef(value)) return false;\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tif (array[i] == value) return true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Get the first item in the supplied array that optionally matches the supplied where function. If no item is found null is returned.\n\t * @memberof FooTable.arr\n\t * @function first\n\t * @param {Array} array - The array to get the item from.\n\t * @param {function} [where] - [Optional] This function must return a boolean value, true indicates that the current item can be returned.\n\t * @returns {(*|null)}\n\t */\n\tF.arr.first = function (array, where) {\n\t\tif (!F.is.array(array)) return null;\n\t\twhere = F.is.fn(where) ? where : returnTrue;\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tif (where(array[i], i)) return array[i];\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Creates a new array from the results of the supplied getter function. If no items are found an empty array is returned, to exclude an item from the results return null.\n\t * @memberof FooTable.arr\n\t * @function map\n\t * @param {Array} array - The array to iterate.\n\t * @param {function} getter - This function must return either a new value or null.\n\t * The first argument is the result being returned at this point in the iteration. The second argument is the current item being iterated.\n\t * @returns {(*|null)}\n\t */\n\tF.arr.map = function (array, getter) {\n\t\tvar result = [], returned = null;\n\t\tif (!F.is.array(array) || !F.is.fn(getter)) return result;\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tif ((returned = getter(array[i], i)) != null) result.push(returned);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Removes items from the array matching the supplied where function. All removed items are returned in a new array.\n\t * @memberof FooTable.arr\n\t * @function remove\n\t * @param {Array} array - The array to iterate and remove items from.\n\t * @param {function} where - This function must return a boolean value, true includes the item in the result array.\n\t * @returns {*}\n\t */\n\tF.arr.remove = function (array, where) {\n\t\tvar remove = [], removed = [];\n\t\tif (!F.is.array(array) || !F.is.fn(where)) return removed;\n\t\tvar i = 0, len = array.length;\n\t\tfor (; i < len; i++) {\n\t\t\tif (where(array[i], i, removed)){\n\t\t\t\tremove.push(i);\n\t\t\t\tremoved.push(array[i]);\n\t\t\t}\n\t\t}\n\t\t// sort the indexes to be removed from largest to smallest\n\t\tremove.sort(function(a, b){ return b - a; });\n\t\ti = 0; len = remove.length;\n\t\tfor(; i < len; i++){\n\t\t\tvar index = remove[i] - i;\n\t\t\tarray.splice(index, 1);\n\t\t}\n\t\treturn removed;\n\t};\n\n\t/**\n\t * Deletes a single item from the array. The item if removed is returned.\n\t * @memberof FooTable.arr\n\t * @function delete\n\t * @param {Array} array - The array to iterate and delete the item from.\n\t * @param {*} item - The item to find and delete.\n\t * @returns {(*|null)}\n\t */\n\tF.arr.delete = function(array, item){\n\t\tvar remove = -1, removed = null;\n\t\tif (!F.is.array(array) || F.is.undef(item)) return removed;\n\t\tvar i = 0, len = array.length;\n\t\tfor (; i < len; i++) {\n\t\t\tif (array[i] == item){\n\t\t\t\tremove = i;\n\t\t\t\tremoved = array[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (remove != -1) array.splice(remove, 1);\n\t\treturn removed;\n\t};\n\n\t/**\n\t * Replaces a single item in the array with a new one.\n\t * @memberof FooTable.arr\n\t * @function replace\n\t * @param {Array} array - The array to iterate and replace the item in.\n\t * @param {*} oldItem - The item to be replaced.\n\t * @param {*} newItem - The item to be inserted.\n\t */\n\tF.arr.replace = function(array, oldItem, newItem){\n\t\tvar index = array.indexOf(oldItem);\n\t\tif (index !== -1) array[index] = newItem;\n\t};\n\n})(FooTable);\n(function (F) {\n\n\t/**\n\t * This namespace contains commonly used 'is' type methods that return boolean values.\n\t * @namespace FooTable.is\n\t */\n\tF.is = {};\n\n\t/**\n\t * Checks if the type of the value is the same as that supplied.\n\t * @memberof FooTable.is\n\t * @function type\n\t * @param {*} value - The value to check the type of.\n\t * @param {string} type - The type to check for.\n\t * @returns {boolean}\n\t */\n\tF.is.type = function (value, type) {\n\t\treturn typeof value === type;\n\t};\n\n\t/**\n\t * Checks if the value is defined.\n\t * @memberof FooTable.is\n\t * @function defined\n\t * @param {*} value - The value to check is defined.\n\t * @returns {boolean}\n\t */\n\tF.is.defined = function (value) {\n\t\treturn typeof value !== 'undefined';\n\t};\n\n\t/**\n\t * Checks if the value is undefined.\n\t * @memberof FooTable.is\n\t * @function undef\n\t * @param {*} value - The value to check is undefined.\n\t * @returns {boolean}\n\t */\n\tF.is.undef = function (value) {\n\t\treturn typeof value === 'undefined';\n\t};\n\n\t/**\n\t * Checks if the value is an array.\n\t * @memberof FooTable.is\n\t * @function array\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.array = function (value) {\n\t\treturn '[object Array]' === Object.prototype.toString.call(value);\n\t};\n\n\t/**\n\t * Checks if the value is a date.\n\t * @memberof FooTable.is\n\t * @function date\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.date = function (value) {\n\t\treturn '[object Date]' === Object.prototype.toString.call(value) && !isNaN(value.getTime());\n\t};\n\n\t/**\n\t * Checks if the value is a boolean.\n\t * @memberof FooTable.is\n\t * @function boolean\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.boolean = function (value) {\n\t\treturn '[object Boolean]' === Object.prototype.toString.call(value);\n\t};\n\n\t/**\n\t * Checks if the value is a string.\n\t * @memberof FooTable.is\n\t * @function string\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.string = function (value) {\n\t\treturn '[object String]' === Object.prototype.toString.call(value);\n\t};\n\n\t/**\n\t * Checks if the value is a number.\n\t * @memberof FooTable.is\n\t * @function number\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.number = function (value) {\n\t\treturn '[object Number]' === Object.prototype.toString.call(value) && !isNaN(value);\n\t};\n\n\t/**\n\t * Checks if the value is a function.\n\t * @memberof FooTable.is\n\t * @function fn\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.fn = function (value) {\n\t\treturn (F.is.defined(window) && value === window.alert) || '[object Function]' === Object.prototype.toString.call(value);\n\t};\n\n\t/**\n\t * Checks if the value is an error.\n\t * @memberof FooTable.is\n\t * @function error\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.error = function (value) {\n\t\treturn '[object Error]' === Object.prototype.toString.call(value);\n\t};\n\n\t/**\n\t * Checks if the value is an object.\n\t * @memberof FooTable.is\n\t * @function object\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.object = function (value) {\n\t\treturn '[object Object]' === Object.prototype.toString.call(value);\n\t};\n\n\t/**\n\t * Checks if the value is a hash.\n\t * @memberof FooTable.is\n\t * @function hash\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.hash = function (value) {\n\t\treturn F.is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;\n\t};\n\n\t/**\n\t * Checks if the supplied object is an HTMLElement\n\t * @memberof FooTable.is\n\t * @function element\n\t * @param {object} obj - The object to check.\n\t * @returns {boolean}\n\t */\n\tF.is.element = function (obj) {\n\t\treturn typeof HTMLElement === 'object'\n\t\t\t? obj instanceof HTMLElement\n\t\t\t: obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string';\n\t};\n\n\t/**\n\t * This is a simple check to determine if an object is a jQuery promise object. It simply checks the object has a \"then\" and \"promise\" function defined.\n\t * The promise object is created as an object literal inside of jQuery.Deferred.\n\t * It has no prototype, nor any other truly unique properties that could be used to distinguish it.\n\t * This method should be a little more accurate than the internal jQuery one that simply checks for a \"promise\" method.\n\t * @memberof FooTable.is\n\t * @function promise\n\t * @param {object} obj - The object to check.\n\t * @returns {boolean}\n\t */\n\tF.is.promise = function(obj){\n\t\treturn F.is.object(obj) && F.is.fn(obj.then) && F.is.fn(obj.promise);\n\t};\n\n\t/**\n\t * Checks if the supplied object is an instance of a jQuery object.\n\t * @memberof FooTable.is\n\t * @function jq\n\t * @param {object} obj - The object to check.\n\t * @returns {boolean}\n\t */\n\tF.is.jq = function(obj){\n\t\treturn F.is.defined(window.jQuery) && obj instanceof jQuery && obj.length > 0;\n\t};\n\n\t/**\n\t * Checks if the supplied object is a moment.js date object.\n\t * @memberof FooTable.is\n\t * @function moment\n\t * @param {object} obj - The object to check.\n\t * @returns {boolean}\n\t */\n\tF.is.moment = function(obj){\n\t\treturn F.is.defined(window.moment) && F.is.object(obj) && F.is.boolean(obj._isAMomentObject)\n\t};\n\n\t/**\n\t * Checks if the supplied value is an object and if it is empty.\n\t * @memberof FooTable.is\n\t * @function emptyObject\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.emptyObject = function(value){\n\t\tif (!F.is.hash(value)) return false;\n\t\tfor(var prop in value) {\n\t\t\tif(value.hasOwnProperty(prop))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\t/**\n\t * Checks if the supplied value is an array and if it is empty.\n\t * @memberof FooTable.is\n\t * @function emptyArray\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.emptyArray = function(value){\n\t\treturn F.is.array(value) ? value.length === 0 : true;\n\t};\n\n\t/**\n\t * Checks if the supplied value is a string and if it is empty.\n\t * @memberof FooTable.is\n\t * @function emptyString\n\t * @param {*} value - The value to check.\n\t * @returns {boolean}\n\t */\n\tF.is.emptyString = function(value){\n\t\treturn F.is.string(value) ? value.length === 0 : true;\n\t};\n\n})(FooTable);\n(function (F) {\n\t/**\n\t * This namespace contains commonly used string utility methods.\n\t * @namespace FooTable.str\n\t */\n\tF.str = {};\n\n\t/**\n\t * Checks if the supplied string contains the given substring.\n\t * @memberof FooTable.str\n\t * @function contains\n\t * @param {string} str - The string to check.\n\t * @param {string} contains - The string to check for.\n\t * @param {boolean} [ignoreCase=false] - Whether or not to ignore casing when performing the check.\n\t * @returns {boolean}\n\t */\n\tF.str.contains = function (str, contains, ignoreCase) {\n\t\tif (F.is.emptyString(str) || F.is.emptyString(contains)) return false;\n\t\treturn contains.length <= str.length\n\t\t\t&& (ignoreCase ? str.toUpperCase().indexOf(contains.toUpperCase()) : str.indexOf(contains)) !== -1;\n\t};\n\n\t/**\n\t * Checks if the supplied string contains the exact given substring.\n\t * @memberof FooTable.str\n\t * @function contains\n\t * @param {string} str - The string to check.\n\t * @param {string} contains - The string to check for.\n\t * @param {boolean} [ignoreCase=false] - Whether or not to ignore casing when performing the check.\n\t * @returns {boolean}\n\t */\n\tF.str.containsExact = function (str, contains, ignoreCase) {\n\t\tif (F.is.emptyString(str) || F.is.emptyString(contains) || contains.length > str.length) return false;\n\t\treturn new RegExp('\\\\b'+ F.str.escapeRegExp(contains)+'\\\\b', ignoreCase ? 'i' : '').test(str);\n\t};\n\n\t/**\n\t * Checks if the supplied string contains the given word.\n\t * @memberof FooTable.str\n\t * @function containsWord\n\t * @param {string} str - The string to check.\n\t * @param {string} word - The word to check for.\n\t * @param {boolean} [ignoreCase=false] - Whether or not to ignore casing when performing the check.\n\t * @returns {boolean}\n\t */\n\tF.str.containsWord = function(str, word, ignoreCase){\n\t\tif (F.is.emptyString(str) || F.is.emptyString(word) || str.length < word.length)\n\t\t\treturn false;\n\t\tvar parts = str.split(/\\W/);\n\t\tfor (var i = 0, len = parts.length; i < len; i++){\n\t\t\tif (ignoreCase ? parts[i].toUpperCase() == word.toUpperCase() : parts[i] == word) return true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Returns the remainder of a string split on the first index of the given substring.\n\t * @memberof FooTable.str\n\t * @function from\n\t * @param {string} str - The string to split.\n\t * @param {string} from - The substring to split on.\n\t * @returns {string}\n\t */\n\tF.str.from = function (str, from) {\n\t\tif (F.is.emptyString(str)) return str;\n\t\treturn F.str.contains(str, from) ? str.substring(str.indexOf(from) + 1) : str;\n\t};\n\n\t/**\n\t * Checks if a string starts with the supplied prefix.\n\t * @memberof FooTable.str\n\t * @function startsWith\n\t * @param {string} str - The string to check.\n\t * @param {string} prefix - The prefix to check for.\n\t * @returns {boolean}\n\t */\n\tF.str.startsWith = function (str, prefix) {\n\t\tif (F.is.emptyString(str)) return str == prefix;\n\t\treturn str.slice(0, prefix.length) == prefix;\n\t};\n\n\t/**\n\t * Takes the supplied string and converts it to camel case.\n\t * @memberof FooTable.str\n\t * @function toCamelCase\n\t * @param {string} str - The string to camel case.\n\t * @returns {string}\n\t */\n\tF.str.toCamelCase = function (str) {\n\t\tif (F.is.emptyString(str)) return str;\n\t\tif (str.toUpperCase() === str) return str.toLowerCase();\n\t\treturn str.replace(/^([A-Z])|[-\\s_](\\w)/g, function (match, p1, p2) {\n\t\t\tif (F.is.string(p2)) return p2.toUpperCase();\n\t\t\treturn p1.toLowerCase();\n\t\t});\n\t};\n\n\t/**\n\t * Generates a random string 9 characters long using the optional prefix if supplied.\n\t * @memberof FooTable.str\n\t * @function random\n\t * @param {string} [prefix] - The prefix to append to the 9 random characters.\n\t * @returns {string}\n\t */\n\tF.str.random = function(prefix){\n\t\tprefix = F.is.emptyString(prefix) ? '' : prefix;\n\t\treturn prefix + Math.random().toString(36).substr(2, 9);\n\t};\n\n\t/**\n\t * Escapes a string for use in a regular expression.\n\t * @memberof FooTable.str\n\t * @function escapeRegExp\n\t * @param {string} str - The string to escape.\n\t * @returns {string}\n\t */\n\tF.str.escapeRegExp = function(str){\n\t\tif (F.is.emptyString(str)) return str;\n\t\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\t};\n\n})(FooTable);\n(function (F) {\n\t\"use strict\";\n\n\tif (!Object.create) {\n\t\tObject.create = (function () {\n\t\t\tvar Object = function () {};\n\t\t\treturn function (prototype) {\n\t\t\t\tif (arguments.length > 1)\n\t\t\t\t\tthrow Error('Second argument not supported');\n\n\t\t\t\tif (!F.is.object(prototype))\n\t\t\t\t\tthrow TypeError('Argument must be an object');\n\n\t\t\t\tObject.prototype = prototype;\n\t\t\t\tvar result = new Object();\n\t\t\t\tObject.prototype = null;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t})();\n\t}\n\n\t/**\n\t * This base implementation does nothing except provide access to the {@link FooTable.Class#extend} method.\n\t * @constructs FooTable.Class\n\t * @classdesc This class is based off of John Resig's [Simple JavaScript Inheritance]{@link http://ejohn.org/blog/simple-javascript-inheritance} but it has been updated to be ES 5.1\n\t * compatible by implementing an [Object.create polyfill]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill}\n\t * for older browsers.\n\t * @see {@link http://ejohn.org/blog/simple-javascript-inheritance}\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill}\n\t * @returns {FooTable.Class}\n\t */\n\tfunction Class() {}\n\n\tvar __extendable__ = /xyz/.test(function () {xyz;}) ? /\\b_super\\b/ : /.*/;\n\n\t// this._super() within the context of the new function is a pointer to the original function\n\t// except if the hook param is specified then the this._super variable is the result of the original function\n\tClass.__extend__ = function(proto, name, func, original){\n\t\t// to all who venture here, here be dragons!\n\t\tproto[name] = F.is.fn(original) && __extendable__.test(func) ?\n\t\t\t(function (name, fn) {\n\t\t\t\treturn function () {\n\t\t\t\t\tvar tmp, ret;\n\t\t\t\t\ttmp = this._super;\n\t\t\t\t\tthis._super = original;\n\t\t\t\t\tret = fn.apply(this, arguments);\n\t\t\t\t\tthis._super = tmp;\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t})(name, func) : func;\n\t};\n\n\t/**\n\t * Creates a new class that inherits from this class which in turn allows itself to be extended or if a name and function is supplied extends only that specific function on the class.\n\t * @param {(object|string)} arg1 - An object containing any new methods/members to implement or the name of the method to extend.\n\t * @param {function} arg2 - If the first argument is a method name then this is the new function to replace it with.\n\t * @returns {FooTable.Class} A new class that inherits from the base class.\n\t * @example <caption>The below shows an example of how to implement inheritance using this method.</caption>\n\t * var Person = FooTable.Class.extend({\n\t *   construct: function(isDancing){\n\t *     this.dancing = isDancing;\n\t *   },\n\t *   dance: function(){\n\t *     return this.dancing;\n\t *   }\n\t * });\n\t *\n\t * var Ninja = Person.extend({\n\t *   construct: function(){\n\t *     this._super( false );\n\t *   },\n\t *   dance: function(){\n\t *     // Call the inherited version of dance()\n\t *     return this._super();\n\t *   },\n\t *   swingSword: function(){\n\t *     return true;\n\t *   }\n\t * });\n\t *\n\t * var p = new Person(true);\n\t * p.dance(); // => true\n\t *\n\t * var n = new Ninja();\n\t * n.dance(); // => false\n\t * n.swingSword(); // => true\n\t *\n\t * // Should all be true\n\t * p instanceof Person && p instanceof FooTable.Class &&\n\t * n instanceof Ninja && n instanceof Person && n instanceof FooTable.Class\n\t */\n\tClass.extend = function (arg1 , arg2) {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\targ1 = args.shift();\n\t\targ2 = args.shift();\n\n\t\tfunction __extend__(proto, name, func, original){\n\t\t\t// to all who venture here, here be dragons!\n\t\t\tproto[name] = F.is.fn(original) && __extendable__.test(func) ?\n\t\t\t\t(function (name, fn, ofn) {\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\tvar tmp, ret;\n\t\t\t\t\t\ttmp = this._super;\n\t\t\t\t\t\tthis._super = ofn;\n\t\t\t\t\t\tret = fn.apply(this, arguments);\n\t\t\t\t\t\tthis._super = tmp;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t};\n\t\t\t\t})(name, func, original) : func;\n\t\t}\n\n\t\tif (F.is.hash(arg1)){\n\t\t\tvar proto = Object.create(this.prototype),\n\t\t\t\t_super = this.prototype;\n\t\t\tfor (var name in arg1) {\n\t\t\t\tif (name === '__ctor__') continue;\n\t\t\t\t__extend__(proto, name, arg1[name], _super[name]);\n\t\t\t}\n\t\t\tvar obj = F.is.fn(proto.__ctor__) ? proto.__ctor__ : function () {\n\t\t\t\tif (!F.is.fn(this.construct))\n\t\t\t\t\tthrow new SyntaxError('FooTable class objects must be constructed with the \"new\" keyword.');\n\t\t\t\tthis.construct.apply(this, arguments);\n\t\t\t};\n\t\t\tproto.construct = F.is.fn(proto.construct) ? proto.construct : function(){};\n\t\t\tobj.prototype = proto;\n\t\t\tproto.constructor = obj;\n\t\t\tobj.extend = Class.extend;\n\t\t\treturn obj;\n\t\t} else if (F.is.string(arg1) && F.is.fn(arg2)) {\n\t\t\t__extend__(this.prototype, arg1, arg2, this.prototype[arg1]);\n\t\t}\n\t};\n\n\tF.Class = Class;\n\n\tF.ClassFactory = F.Class.extend(/** @lends FooTable.ClassFactory */{\n\t\t/**\n\t\t * This is a simple factory for {@link FooTable.Class} objects allowing them to be registered using a friendly name\n\t\t * and then new instances can be created using this friendly name.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @returns {FooTable.ClassFactory}\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\tconstruct: function(){\n\t\t\t/**\n\t\t\t * An object containing all registered classes.\n\t\t\t * @type {{}}\n\t\t\t */\n\t\t\tthis.registered = {};\n\t\t},\n\t\t/**\n\t\t * Checks if the factory contains a class registered using the supplied name.\n\t\t * @instance\n\t\t * @param {string} name - The name of the class to check.\n\t\t * @returns {boolean}\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\tcontains: function(name){\n\t\t\treturn F.is.defined(this.registered[name]);\n\t\t},\n\t\t/**\n\t\t * Gets an array of all registered names.\n\t\t * @instance\n\t\t * @returns {Array.<string>}\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\tnames: function(){\n\t\t\tvar names = [], name;\n\t\t\tfor (name in this.registered){\n\t\t\t\tif (!this.registered.hasOwnProperty(name)) continue;\n\t\t\t\tnames.push(name);\n\t\t\t}\n\t\t\treturn names;\n\t\t},\n\t\t/**\n\t\t * Registers a class object using the supplied friendly name and priority. The priority is only taken into account when loading all registered classes\n\t\t * using the {@link FooTable.ClassFactory#load} method.\n\t\t * @instance\n\t\t * @param {string} name - The friendly name of the class.\n\t\t * @param {function} klass - The class to register.\n\t\t * @param {number} priority - This determines the order that the class is created when using the {@link FooTable.ClassFactory#load} method, higher values are loaded first.\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\tregister: function(name, klass, priority){\n\t\t\tif (!F.is.string(name) || !F.is.fn(klass)) return;\n\t\t\tvar current = this.registered[name];\n\t\t\tthis.registered[name] = {\n\t\t\t\tname: name,\n\t\t\t\tklass: klass,\n\t\t\t\tpriority: F.is.number(priority) ? priority : (F.is.defined(current) ? current.priority : 0)\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * Creates new instances of all registered classes using there priority and the supplied arguments to return them in an array.\n\t\t * @instance\n\t\t * @param {object} subs - An object containing classes to substitute on load.\n\t\t * @param {*} arg1 - The first argument to supply when creating new instances of all registered classes.\n\t\t * @param {*} [argN...] - Any number of additional arguments to supply when creating new instances of all registered classes.\n\t\t * @returns {Array.<FooTable.Class>}\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\tload: function(subs, arg1, argN){\n\t\t\tvar self = this, args = Array.prototype.slice.call(arguments), reg = [], loaded = [], name, klass;\n\t\t\tsubs = args.shift() || {};\n\t\t\tfor (name in self.registered){\n\t\t\t\tif (!self.registered.hasOwnProperty(name)) continue;\n\t\t\t\tvar component = self.registered[name];\n\t\t\t\tif (subs.hasOwnProperty(name)){\n\t\t\t\t\tklass = subs[name];\n\t\t\t\t\tif (F.is.string(klass)) klass = F.getFnPointer(subs[name]);\n\t\t\t\t\tif (F.is.fn(klass)){\n\t\t\t\t\t\tcomponent = {name: name, klass: klass, priority: self.registered[name].priority};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treg.push(component);\n\t\t\t}\n\t\t\tfor (name in subs){\n\t\t\t\tif (!subs.hasOwnProperty(name) || self.registered.hasOwnProperty(name)) continue;\n\t\t\t\tklass = subs[name];\n\t\t\t\tif (F.is.string(klass)) klass = F.getFnPointer(subs[name]);\n\t\t\t\tif (F.is.fn(klass)){\n\t\t\t\t\treg.push({name: name, klass: klass, priority: 0});\n\t\t\t\t}\n\t\t\t}\n\t\t\treg.sort(function(a, b){ return b.priority - a.priority; });\n\t\t\tF.arr.each(reg, function(r){\n\t\t\t\tif (F.is.fn(r.klass)){\n\t\t\t\t\tloaded.push(self._make(r.klass, args));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn loaded;\n\t\t},\n\t\t/**\n\t\t * Create a new instance of a single class using the supplied name and arguments.\n\t\t * @instance\n\t\t * @param {string} name - The name of the class to create.\n\t\t * @param {*} arg1 - The first argument to supply to the new instance.\n\t\t * @param {*} [argN...] - Any number of additional arguments to supply to the new instance.\n\t\t * @returns {FooTable.Class}\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\tmake: function(name, arg1, argN){\n\t\t\tvar self = this, args = Array.prototype.slice.call(arguments), reg;\n\t\t\tname = args.shift();\n\t\t\treg = self.registered[name];\n\t\t\tif (F.is.fn(reg.klass)){\n\t\t\t\treturn self._make(reg.klass, args);\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * This in effect lets us use the \"apply\" method on a function using the \"new\" keyword.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {function} klass\n\t\t * @param args\n\t\t * @returns {FooTable.Class}\n\t\t * @this FooTable.ClassFactory\n\t\t */\n\t\t_make: function(klass, args){\n\t\t\tfunction Class() {\n\t\t\t\treturn klass.apply(this, args);\n\t\t\t}\n\t\t\tClass.prototype = klass.prototype;\n\t\t\treturn new Class();\n\t\t}\n\t});\n\n})(FooTable);\n(function($, F){\n\n\t/**\n\t * Converts the supplied cssText string into JSON object.\n\t * @param {string} cssText - The cssText to convert to a JSON object.\n\t * @returns {object}\n\t */\n\tF.css2json = function(cssText){\n\t\tif (F.is.emptyString(cssText)) return {};\n\t\tvar json = {}, props = cssText.split(';'), pair, key, value;\n\t\tfor (var i = 0, i_len = props.length; i < i_len; i++){\n\t\t\tif (F.is.emptyString(props[i])) continue;\n\t\t\tpair = props[i].split(':');\n\t\t\tif (F.is.emptyString(pair[0]) || F.is.emptyString(pair[1])) continue;\n\t\t\tkey = F.str.toCamelCase($.trim(pair[0]));\n\t\t\tvalue = $.trim(pair[1]);\n\t\t\tjson[key] = value;\n\t\t}\n\t\treturn json;\n\t};\n\n\t/**\n\t * Attempts to retrieve a function pointer using the given name.\n\t * @param {string} functionName - The name of the function to fetch a pointer to.\n\t * @returns {(function|object|null)}\n\t */\n\tF.getFnPointer = function(functionName){\n\t\tif (F.is.emptyString(functionName)) return null;\n\t\tvar pointer = window,\n\t\t\tparts = functionName.split('.');\n\t\tF.arr.each(parts, function(part){\n\t\t\tif (pointer[part]) pointer = pointer[part];\n\t\t});\n\t\treturn F.is.fn(pointer) ? pointer : null;\n\t};\n\n\t/**\n\t * Checks the value for function properties such as the {@link FooTable.Column#formatter} option which could also be specified using just the name\n\t * and attempts to return the correct function pointer or null if none was found matching the value.\n\t * @param {FooTable.Class} self - The class to use as the 'this' keyword within the context of the function.\n\t * @param {(function|string)} value - The actual function or the name of the function for the property.\n\t * @param {function} [def] - A default function to return if none is found.\n\t * @returns {(function|null)}\n\t */\n\tF.checkFnValue = function(self, value, def){\n\t\tdef = F.is.fn(def) ? def : null;\n\t\tfunction wrap(t, fn, d){\n\t\t\tif (!F.is.fn(fn)) return d;\n\t\t\treturn function(){\n\t\t\t\treturn fn.apply(t, arguments);\n\t\t\t};\n\t\t}\n\t\treturn F.is.fn(value) ? wrap(self, value, def) : (F.is.type(value, 'string') ? wrap(self, F.getFnPointer(value), def) : def);\n\t};\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.Cell = F.Class.extend(/** @lends FooTable.Cell */{\n\t\t/**\n\t\t * The cell class containing all the properties for cells.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {FooTable.Table} table -  The root {@link FooTable.Table} this cell belongs to.\n\t\t * @param {FooTable.Row} row - The parent {@link FooTable.Row} this cell belongs to.\n\t\t * @param {FooTable.Column} column - The {@link FooTable.Column} this cell falls under.\n\t\t * @param {(*|HTMLElement|jQuery)} valueOrElement - Either the value or the element for the cell.\n\t\t * @returns {FooTable.Cell}\n\t\t * @this FooTable.Cell\n\t\t */\n\t\tconstruct: function (table, row, column, valueOrElement) {\n\t\t\t/**\n\t\t\t * The root {@link FooTable.Table} for the cell.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {FooTable.Table}\n\t\t\t */\n\t\t\tthis.ft = table;\n\t\t\t/**\n\t\t\t * The parent {@link FooTable.Row} for the cell.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {FooTable.Row}\n\t\t\t */\n\t\t\tthis.row = row;\n\t\t\t/**\n\t\t\t * The {@link FooTable.Column} this cell falls under.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {FooTable.Column}\n\t\t\t */\n\t\t\tthis.column = column;\n\t\t\tthis.created = false;\n\t\t\tthis.define(valueOrElement);\n\t\t},\n\t\t/**\n\t\t * This is supplied either the value or the cell element/jQuery object if it exists.\n\t\t * If supplied the element we need set the $el property and parse the value from it.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or element to define the cell.\n\t\t * @this FooTable.Cell\n\t\t */\n\t\tdefine: function(valueOrElement){\n\t\t\t/**\n\t\t\t * The jQuery table cell object this instance wraps.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$el = F.is.element(valueOrElement) || F.is.jq(valueOrElement) ? $(valueOrElement) : null;\n\t\t\t/**\n\t\t\t * The jQuery row object that represents this cell in the details table.\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$detail = null;\n\n\t\t\tvar hasOptions = F.is.hash(valueOrElement) && F.is.hash(valueOrElement.options) && F.is.defined(valueOrElement.value);\n\n\t\t\t/**\n\t\t\t * The value of the cell.\n\t\t\t * @instance\n\t\t\t * @type {*}\n\t\t\t */\n\t\t\tthis.value = this.column.parser.call(this.column, F.is.jq(this.$el) ? this.$el : (hasOptions ? valueOrElement.value : valueOrElement), this.ft.o);\n\n\t\t\t/**\n\t\t\t * Contains any options for the cell. These are the options supplied through the plugin constructor as part of the row object itself.\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.o = $.extend(true, {\n\t\t\t\tclasses: null,\n\t\t\t\tstyle: null\n\t\t\t}, hasOptions ? valueOrElement.options : {});\n\t\t\t/**\n\t\t\t * An array of CSS classes for the cell.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {Array.<string>}\n\t\t\t */\n\t\t\tthis.classes = F.is.jq(this.$el) && this.$el.attr('class') ? this.$el.attr('class').match(/\\S+/g) : (F.is.array(this.o.classes) ? this.o.classes : (F.is.string(this.o.classes) ? this.o.classes.match(/\\S+/g) : []));\n\t\t\t/**\n\t\t\t * The inline styles for the cell.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.style = F.is.jq(this.$el) && this.$el.attr('style') ? F.css2json(this.$el.attr('style')) : (F.is.hash(this.o.style) ? this.o.style : (F.is.string(this.o.style) ? F.css2json(this.o.style) : {}));\n\t\t},\n\t\t/**\n\t\t * After the cell has been defined this ensures that the $el and #detail properties are jQuery objects by either creating or updating them.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Cell\n\t\t */\n\t\t$create: function(){\n\t\t\tif (this.created) return;\n\t\t\t(this.$el = F.is.jq(this.$el) ? this.$el : $('<td/>'))\n\t\t\t\t.data('value', this.value)\n\t\t\t\t.contents().detach().end()\n\t\t\t\t.append(this.format(this.value));\n\n\t\t\tthis._setClasses(this.$el);\n\t\t\tthis._setStyle(this.$el);\n\n\t\t\tthis.$detail = $('<tr/>').addClass(this.row.classes.join(' '))\n\t\t\t\t.data('__FooTableCell__', this)\n\t\t\t\t.append($('<th/>'))\n\t\t\t\t.append($('<td/>'));\n\n\t\t\tthis.created = true;\n\t\t},\n\t\t/**\n\t\t * Collapses this cell and displays it in the details row.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tcollapse: function(){\n\t\t\tif (!this.created) return;\n\t\t\tthis.$detail.children('th').html(this.column.title);\n\t\t\tthis.$el.clone()\n\t\t\t\t.attr('id', this.$el.attr('id') ? this.$el.attr('id') + '-detail' : undefined)\n\t\t\t\t.css('display', 'table-cell')\n\t\t\t\t.html('')\n\t\t\t\t.append(this.$el.contents().detach())\n\t\t\t\t.replaceAll(this.$detail.children('td').first());\n\n\t\t\tif (!F.is.jq(this.$detail.parent()))\n\t\t\t\tthis.$detail.appendTo(this.row.$details.find('.footable-details > tbody'));\n\t\t},\n\t\t/**\n\t\t * Restores this cell from a detail row back into the normal row.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\trestore: function(){\n\t\t\tif (!this.created) return;\n\t\t\tif (F.is.jq(this.$detail.parent())){\n\t\t\t\tvar $cell = this.$detail.children('td').first();\n\t\t\t\tthis.$el\n\t\t\t\t\t.attr('class', $cell.attr('class'))\n\t\t\t\t\t.attr('style', $cell.attr('style'))\n\t\t\t\t\t.css('display', (this.column.hidden || !this.column.visible) ? 'none' : 'table-cell')\n\t\t\t\t\t.append($cell.contents().detach());\n\t\t\t}\n\t\t\tthis.$detail.detach();\n\t\t},\n\t\t/**\n\t\t * Helper method to call this cell's column parser function supplying the required parameters.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {*}\n\t\t * @see FooTable.Column#parser\n\t\t * @this FooTable.Cell\n\t\t */\n\t\tparse: function(){\n\t\t\treturn this.column.parser.call(this.column, this.$el, this.ft.o);\n\t\t},\n\t\t/**\n\t\t * Helper method to call this cell's column formatter function using the supplied value and any additional required parameters.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {*} value - The value to format.\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t * @see FooTable.Column#formatter\n\t\t * @this FooTable.Cell\n\t\t */\n\t\tformat: function(value){\n\t\t\treturn this.column.formatter.call(this.column, value, this.ft.o, this.row.value);\n\t\t},\n\t\t/**\n\t\t * Allows easy access to getting or setting the cell's value. If the value is set all associated properties are also updated along with the actual element.\n\t\t * Using this method also allows us to supply an object containing options and the value for the cell.\n\t\t * @instance\n\t\t * @param {*} [value] - The value to set for the cell. If not supplied the current value of the cell is returned.\n\t\t * @param {boolean} [redraw=true] - Whether or not to redraw the row once the value has been set.\n\t\t * @param {boolean} [redrawSelf=true] - Whether or not to redraw the cell itself once the value has been set, if `false` this will override the supplied `redraw` value and prevent the row from redrawing as well.\n\t\t * @returns {(*|undefined)}\n\t\t * @this FooTable.Cell\n\t\t */\n\t\tval: function(value, redraw, redrawSelf){\n\t\t\tif (F.is.undef(value)){\n\t\t\t\t// get\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t\t// set\n\t\t\tvar self = this, hasOptions = F.is.hash(value) && F.is.hash(value.options) && F.is.defined(value.value);\n\t\t\tthis.o = $.extend(true, {\n\t\t\t\tclasses: self.classes,\n\t\t\t\tstyle: self.style\n\t\t\t}, hasOptions ? value.options : {});\n\n\t\t\tthis.value = hasOptions ? value.value : value;\n\t\t\tthis.classes = F.is.array(this.o.classes) ? this.o.classes : (F.is.string(this.o.classes) ? this.o.classes.match(/\\S+/g) : []);\n\t\t\tthis.style = F.is.hash(this.o.style) ? this.o.style : (F.is.string(this.o.style) ? F.css2json(this.o.style) : {});\n\n\t\t\tredrawSelf = F.is.boolean(redrawSelf) ? redrawSelf : true;\n\t\t\tif (this.created && redrawSelf){\n\t\t\t\tthis.$el.data('value', this.value).empty();\n\n\t\t\t\tvar $detail = this.$detail.children('td').first().empty(),\n\t\t\t\t\t$target = F.is.jq(this.$detail.parent()) ? $detail : this.$el;\n\n\t\t\t\t$target.append(this.format(this.value));\n\n\t\t\t\tthis._setClasses($target);\n\t\t\t\tthis._setStyle($target);\n\n\t\t\t\tif (F.is.boolean(redraw) ? redraw : true) this.row.draw();\n\t\t\t}\n\t\t},\n\t\t_setClasses: function($el){\n\t\t\tvar hasColClasses = !F.is.emptyArray(this.column.classes),\n\t\t\t\thasClasses = !F.is.emptyArray(this.classes),\n\t\t\t\tclasses = null;\n\t\t\t$el.removeAttr('class');\n\t\t\tif (!hasColClasses && !hasClasses) return;\n\t\t\tif (hasColClasses && hasClasses){\n\t\t\t\tclasses = this.classes.concat(this.column.classes).join(' ');\n\t\t\t} else if (hasColClasses) {\n\t\t\t\tclasses = this.column.classes.join(' ');\n\t\t\t} else if (hasClasses){\n\t\t\t\tclasses = this.classes.join(' ');\n\t\t\t}\n\t\t\tif (!F.is.emptyString(classes)){\n\t\t\t\t$el.addClass(classes);\n\t\t\t}\n\t\t},\n\t\t_setStyle: function($el){\n\t\t\tvar hasColStyle = !F.is.emptyObject(this.column.style),\n\t\t\t\thasStyle = !F.is.emptyObject(this.style),\n\t\t\t\tstyle = null;\n\t\t\t$el.removeAttr('style');\n\t\t\tif (!hasColStyle && !hasStyle) return;\n\t\t\tif (hasColStyle && hasStyle){\n\t\t\t\tstyle = $.extend({}, this.column.style, this.style);\n\t\t\t} else if (hasColStyle) {\n\t\t\t\tstyle = this.column.style;\n\t\t\t} else if (hasStyle){\n\t\t\t\tstyle = this.style;\n\t\t\t}\n\t\t\tif (F.is.hash(style)){\n\t\t\t\t$el.css(style);\n\t\t\t}\n\t\t}\n\t});\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.Column = F.Class.extend(/** @lends FooTable.Column */{\n\t\t/**\n\t\t * The column class containing all the properties for columns. All members marked as \"readonly\" should not be used when defining {@link FooTable.Defaults#columns}.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this component belongs to.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t * @param {string} [type] - The type of column, \"text\" by default.\n\t\t * @returns {FooTable.Column}\n\t\t * @this FooTable.Column\n\t\t */\n\t\tconstruct: function(instance, definition, type){\n\t\t\t/**\n\t\t\t * The root {@link FooTable.Table} for the column.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {FooTable.Table}\n\t\t\t */\n\t\t\tthis.ft = instance;\n\t\t\t/**\n\t\t\t * The type of data displayed by the column.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.type = F.is.emptyString(type) ? 'text' : type;\n\t\t\t/**\n\t\t\t * Whether or not the column was parsed from a standard table row containing data instead of from an actual header row.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.virtual = F.is.boolean(definition.virtual) ? definition.virtual : false;\n\t\t\t/**\n\t\t\t * The jQuery cell object for the column header.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$el = F.is.jq(definition.$el) ? definition.$el : null;\n\t\t\t/**\n\t\t\t * The index of the column in the table. This is set by the plugin during initialization.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {number}\n\t\t\t * @default -1\n\t\t\t */\n\t\t\tthis.index = F.is.number(definition.index) ? definition.index : -1;\n\t\t\t/**\n\t\t\t * Whether or not this in an internal only column.\n\t\t\t * @instance\n\t\t\t * @readonly\n\t\t\t * @type {boolean}\n\t\t\t * @description Internal columns or there cells will not be returned when calling methods such as `FooTable.Row#val`.\n\t\t\t */\n\t\t\tthis.internal = false;\n\t\t\tthis.define(definition);\n\t\t\tthis.$create();\n\t\t},\n\t\t/**\n\t\t * This is supplied the column definition in the form of a simple object created by merging options supplied via the plugin constructor with those parsed from the DOM.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} definition - The object containing the column definition.\n\t\t * @this FooTable.Column\n\t\t */\n\t\tdefine: function(definition){\n\t\t\t/**\n\t\t\t * Whether or not this column is hidden from view and appears in the details row.\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.hidden = F.is.boolean(definition.hidden) ? definition.hidden : false;\n\t\t\t/**\n\t\t\t * Whether or not this column is completely hidden from view and will not appear in the details row.\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.visible = F.is.boolean(definition.visible) ? definition.visible : true;\n\n\t\t\t/**\n\t\t\t * The name of the column. This name must correspond to the property name of the JSON row data.\n\t\t\t * @type {string}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.name = F.is.string(definition.name) ? definition.name : null;\n\t\t\tif (this.name == null) this.name = 'col'+(definition.index+1);\n\t\t\t/**\n\t\t\t * The title to display in the column header, this can be HTML.\n\t\t\t * @type {string}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.title = F.is.string(definition.title) ? definition.title : null;\n\t\t\tif (!this.virtual && this.title == null && F.is.jq(this.$el)) this.title = this.$el.html();\n\t\t\tif (this.title == null) this.title = 'Column '+(definition.index+1);\n\t\t\t/**\n\t\t\t * The styles to apply to all cells in this column.\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.style = F.is.hash(definition.style) ? definition.style : (F.is.string(definition.style) ? F.css2json(definition.style) : {});\n\t\t\t/**\n\t\t\t * The classes to apply to all cells in this column.\n\t\t\t * @type {Array.<string>}\n\t\t\t */\n\t\t\tthis.classes = F.is.array(definition.classes) ? definition.classes : (F.is.string(definition.classes) ? definition.classes.match(/\\S+/g) : []);\n\n\t\t\t// override any default functions ensuring when they are executed \"this\" within the context of the function points to the instance of this object.\n\t\t\tthis.parser = F.checkFnValue(this, definition.parser, this.parser);\n\t\t\tthis.formatter = F.checkFnValue(this, definition.formatter, this.formatter);\n\t\t},\n\t\t/**\n\t\t * After the column has been defined this ensures that the $el property is a jQuery object by either creating or updating the current value.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Column\n\t\t */\n\t\t$create: function(){\n\t\t\t(this.$el = !this.virtual && F.is.jq(this.$el) ? this.$el : $('<th/>')).html(this.title).addClass(this.classes.join(' ')).css(this.style);\n\t\t},\n\t\t/**\n\t\t * This is supplied either the cell value or jQuery object to parse. Any value can be returned from this method and will be provided to the {@link FooTable.Column#format} function\n\t\t * to generate the cell contents.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {string}\n\t\t * @this FooTable.Column\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){ // use jQuery to get the value\n\t\t\t\tvar data = $(valueOrElement).data('value');\n\t\t\t\treturn F.is.defined(data) ? data : $(valueOrElement).html();\n\t\t\t}\n\t\t\tif (F.is.defined(valueOrElement) && valueOrElement != null) return valueOrElement+''; // use the native toString of the value\n\t\t\treturn null; // otherwise we have no value so return null\n\t\t},\n\t\t/**\n\t\t * This is supplied the value retrieved from the {@link FooTable.Column#parse} function and must return a string, HTMLElement or jQuery object.\n\t\t * The return value from this function is what is displayed in the cell in the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {string} value - The value to format.\n\t\t * @param {object} options - The current plugin options.\n\t\t * @param {object} rowData - An object containing the current row data.\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t * @this FooTable.Column\n\t\t */\n\t\tformatter: function(value, options, rowData){\n\t\t\treturn value == null ? '' : value;\n\t\t},\n\t\t/**\n\t\t * Creates a cell for this column from the supplied {@link FooTable.Row} object. This allows different column types to return different types of cells.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {FooTable.Row} row - The row to create the cell from.\n\t\t * @returns {FooTable.Cell}\n\t\t * @this FooTable.Column\n\t\t */\n\t\tcreateCell: function(row){\n\t\t\tvar element = F.is.jq(row.$el) ? row.$el.children('td,th').get(this.index) : null,\n\t\t\t\tdata = F.is.hash(row.value) ? row.value[this.name] : null;\n\t\t\treturn new F.Cell(this.ft, row, this, element || data);\n\t\t}\n\t});\n\n\tF.columns = new F.ClassFactory();\n\n\tF.columns.register('text', F.Column);\n\n})(jQuery, FooTable);\n(function ($, F) {\n\n\tF.Component = F.Class.extend(/** @lends FooTable.Component */{\n\t\t/**\n\t\t * The base class for all FooTable components.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {FooTable.Table} instance - The parent {@link FooTable.Table} object for the component.\n\t\t * @param {boolean} enabled - Whether or not the component is enabled.\n\t\t * @throws {TypeError} The instance parameter must be an instance of {@link FooTable.Table}.\n\t\t * @returns {FooTable.Component}\n\t\t */\n\t\tconstruct: function (instance, enabled) {\n\t\t\tif (!(instance instanceof F.Table))\n\t\t\t\tthrow new TypeError('The instance parameter must be an instance of FooTable.Table.');\n\n\t\t\t/**\n\t\t\t * The parent {@link FooTable.Table} for the component.\n\t\t\t * @type {FooTable.Table}\n\t\t\t */\n\t\t\tthis.ft = instance;\n\t\t\t/**\n\t\t\t * Whether or not this component is enabled. Disabled components only have there preinit method called allowing for this value to be overridden.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.enabled = F.is.boolean(enabled) ? enabled : false;\n\t\t},\n\t\t/**\n\t\t * The preinit method is called during the parent {@link FooTable.Table} constructor call.\n\t\t * @param {object} data - The jQuery.data() object of the root table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @function\n\t\t */\n\t\tpreinit: function(data){},\n\t\t/**\n\t\t * The init method is called during the parent {@link FooTable.Table} constructor call.\n\t\t * @instance\n\t\t * @protected\n\t\t * @function\n\t\t */\n\t\tinit: function(){},\n\t\t/**\n\t\t * This method is called from the {@link FooTable.Table#destroy} method.\n\t\t * @instance\n\t\t * @protected\n\t\t * @function\n\t\t */\n\t\tdestroy: function(){},\n\t\t/**\n\t\t * This method is called from the {@link FooTable.Table#draw} method.\n\t\t * @instance\n\t\t * @protected\n\t\t * @function\n\t\t */\n\t\tpredraw: function(){},\n\t\t/**\n\t\t * This method is called from the {@link FooTable.Table#draw} method.\n\t\t * @instance\n\t\t * @protected\n\t\t * @function\n\t\t */\n\t\tdraw: function(){},\n\t\t/**\n\t\t * This method is called from the {@link FooTable.Table#draw} method.\n\t\t * @instance\n\t\t * @protected\n\t\t * @function\n\t\t */\n\t\tpostdraw: function(){}\n\t});\n\n\tF.components = new F.ClassFactory();\n\n})(jQuery, FooTable);\n(function ($, F) {\n\t/**\n\t * Contains all the available options for the FooTable plugin.\n\t * @name FooTable.Defaults\n\t * @function\n\t * @constructor\n\t * @returns {FooTable.Defaults}\n\t */\n\tF.Defaults = function () {\n\t\t/**\n\t\t * Whether or not events raised using the {@link FooTable.Table#raise} method are propagated up the DOM. By default this is set to false and all events bubble up the DOM as per usual\n\t\t * however the reason for this option is if we have nested tables. If false the parent table would receive all the events raised by it's children and any handlers bound to both the\n\t\t * parent and child would be triggered which is not the desired behavior.\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stopPropagation = false;\n\t\t/**\n\t\t * An object in which the string keys represent one or more space-separated event types and optional namespaces, and the values represent a handler function to be called for the event(s).\n\t\t * @type {object.<string, function>}\n\t\t * @default NULL\n\t\t * @example <caption>This example shows how to pass an object containing the events and handlers.</caption>\n\t\t * \"on\": {\n\t\t * \t\"click\": function(e){\n\t\t * \t\t// bind a custom click event to do something whenever the table is clicked\n\t\t * \t},\n\t\t * \t\"init.ft.table\": function(e, ft){\n\t\t * \t\t// bind to the FooTable initialize event to do something\n\t\t * \t}\n\t\t * }\n\t\t */\n\t\tthis.on = null;\n\t};\n\n\t/**\n\t * Contains all the default options for the plugin.\n\t * @type {FooTable.Defaults}\n\t */\n\tF.defaults = new F.Defaults();\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.Row = F.Class.extend(/** @lends FooTable.Row */{\n\t\t/**\n\t\t * The row class containing all the properties for a row and its' cells.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {FooTable.Table} table -  The parent {@link FooTable.Table} this component belongs to.\n\t\t * @param {Array.<FooTable.Column>} columns - The array of {@link FooTable.Column} for this row.\n\t\t * @param {(*|HTMLElement|jQuery)} dataOrElement - Either the data for the row (create) or the element (parse) for the row.\n\t\t * @returns {FooTable.Row}\n\t\t */\n\t\tconstruct: function (table, columns, dataOrElement) {\n\t\t\t/**\n\t\t\t * The {@link FooTable.Table} for the row.\n\t\t\t * @type {FooTable.Table}\n\t\t\t */\n\t\t\tthis.ft = table;\n\t\t\t/**\n\t\t\t * The array of {@link FooTable.Column} for this row.\n\t\t\t * @type {Array.<FooTable.Column>}\n\t\t\t */\n\t\t\tthis.columns = columns;\n\n\t\t\tthis.created = false;\n\t\t\tthis.define(dataOrElement);\n\t\t},\n\t\t/**\n\t\t * This is supplied either the object containing the values for the row or the row element/jQuery object if it exists.\n\t\t * If supplied the element we need to set the $el property and parse the cells from it using the column index.\n\t\t * If we have an object we parse the cells from it using the column name.\n\t\t * @param {(object|jQuery)} dataOrElement - The row object or element to define the row.\n\t\t */\n\t\tdefine: function(dataOrElement){\n\t\t\t/**\n\t\t\t * The jQuery table row object this instance wraps.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$el = F.is.element(dataOrElement) || F.is.jq(dataOrElement) ? $(dataOrElement) : null;\n\t\t\t/**\n\t\t\t * The jQuery toggle element for the row.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$toggle = $('<i/>', {'class': 'footable-toggle icon ion-md-add'});\n\n\t\t\tvar isObj = F.is.hash(dataOrElement),\n\t\t\t\thasOptions = isObj && F.is.hash(dataOrElement.options) && F.is.hash(dataOrElement.value);\n\n\t\t\t/**\n\t\t\t * The value of the row.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.value = isObj ? (hasOptions ? dataOrElement.value : dataOrElement) : null;\n\n\t\t\t/**\n\t\t\t * Contains any options for the row.\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.o = $.extend(true, {\n\t\t\t\texpanded: false,\n\t\t\t\tclasses: null,\n\t\t\t\tstyle: null\n\t\t\t}, hasOptions ? dataOrElement.options : {});\n\n\t\t\t/**\n\t\t\t * Whether or not this row is expanded and will display it's detail row when there are any hidden columns.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.expanded = F.is.jq(this.$el) ? (this.$el.data('expanded') || this.o.expanded) : this.o.expanded;\n\t\t\t/**\n\t\t\t * An array of CSS classes for the row.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {Array.<string>}\n\t\t\t */\n\t\t\tthis.classes = F.is.jq(this.$el) && this.$el.attr('class') ? this.$el.attr('class').match(/\\S+/g) : (F.is.array(this.o.classes) ? this.o.classes : (F.is.string(this.o.classes) ? this.o.classes.match(/\\S+/g) : []));\n\t\t\t/**\n\t\t\t * The inline styles for the row.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.style = F.is.jq(this.$el) && this.$el.attr('style') ? F.css2json(this.$el.attr('style')) : (F.is.hash(this.o.style) ? this.o.style : (F.is.string(this.o.style) ? F.css2json(this.o.style) : {}));\n\n\t\t\t/**\n\t\t\t * The cells array. This is populated before the call to the {@link FooTable.Row#$create} method.\n\t\t\t * @instance\n\t\t\t * @type {Array.<FooTable.Cell>}\n\t\t\t */\n\t\t\tthis.cells = this.createCells();\n\n\t\t\t// this ensures the value contains the parsed cell values and not the supplied values\n\t\t\tvar self = this;\n\t\t\tself.value = {};\n\t\t\tF.arr.each(self.cells, function(cell){\n\t\t\t\tself.value[cell.column.name] = cell.val();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * After the row has been defined this ensures that the $el property is a jQuery object by either creating or updating the current value.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Row\n\t\t */\n\t\t$create: function(){\n\t\t\tif (this.created) return;\n\t\t\t(this.$el = F.is.jq(this.$el) ? this.$el : $('<tr/>'))\n\t\t\t\t.data('__FooTableRow__', this);\n\n\t\t\tthis._setClasses(this.$el);\n\t\t\tthis._setStyle(this.$el);\n\n\t\t\tif (this.ft.rows.toggleColumn == 'last') this.$toggle.addClass('last-column');\n\n\t\t\tthis.$details = $('<tr/>', { 'class': 'footable-detail-row' })\n\t\t\t\t.append($('<td/>', { colspan: this.ft.columns.visibleColspan })\n\t\t\t\t\t.append($('<table/>', { 'class': 'footable-details ' + this.ft.classes.join(' ') })\n\t\t\t\t\t\t.append('<tbody/>')));\n\n\t\t\tvar self = this;\n\t\t\tF.arr.each(self.cells, function(cell){\n\t\t\t\tif (!cell.created) cell.$create();\n\t\t\t\tself.$el.append(cell.$el);\n\t\t\t});\n\t\t\tself.$el.off('click.ft.row').on('click.ft.row', { self: self }, self._onToggle);\n\t\t\tthis.created = true;\n\t\t},\n\t\t/**\n\t\t * This is called during the construct method and uses the current column definitions to create an array of {@link FooTable.Cell} objects for the row.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {Array.<FooTable.Cell>}\n\t\t * @this FooTable.Row\n\t\t */\n\t\tcreateCells: function(){\n\t\t\tvar self = this;\n\t\t\treturn F.arr.map(self.columns, function(col){\n\t\t\t\treturn col.createCell(self);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Allows easy access to getting or setting the row's data. If the data is set all associated properties are also updated along with the actual element.\n\t\t * Using this method also allows us to supply an object containing options and the data for the row at the same time.\n\t\t * @instance\n\t\t * @param {object} [data] - The data to set for the row. If not supplied the current value of the row is returned.\n\t\t * @param {boolean} [redraw=true] - Whether or not to redraw the table once the value has been set.\n\t\t * @param {boolean} [redrawSelf=true] - Whether or not to redraw the row itself once the value has been set, if `false` this will override the supplied `redraw` value and prevent the table from redrawing as well.\n\t\t * @returns {(*|undefined)}\n\t\t */\n\t\tval: function(data, redraw, redrawSelf){\n\t\t\tvar self = this;\n\t\t\tif (!F.is.hash(data)){\n\t\t\t\t// get - check the value property and build it from the cells if required.\n\t\t\t\tif (!F.is.hash(this.value) || F.is.emptyObject(this.value)){\n\t\t\t\t\tthis.value = {};\n\t\t\t\t\tF.arr.each(this.cells, function(cell){\n\t\t\t\t\t\tif (!cell.column.internal){\n\t\t\t\t\t\t\tself.value[cell.column.name] = cell.val();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t\t// set\n\t\t\tthis.collapse(false);\n\t\t\tvar isObj = F.is.hash(data),\n\t\t\t\thasOptions = isObj && F.is.hash(data.options) && F.is.hash(data.value);\n\n\t\t\tthis.o = $.extend(true, {\n\t\t\t\texpanded: self.expanded,\n\t\t\t\tclasses: self.classes,\n\t\t\t\tstyle: self.style\n\t\t\t}, hasOptions ? data.options : {});\n\n\t\t\tthis.expanded = this.o.expanded;\n\t\t\tthis.classes = F.is.array(this.o.classes) ? this.o.classes : (F.is.string(this.o.classes) ? this.o.classes.match(/\\S+/g) : []);\n\t\t\tthis.style = F.is.hash(this.o.style) ? this.o.style : (F.is.string(this.o.style) ? F.css2json(this.o.style) : {});\n\t\t\tif (isObj) {\n\t\t\t\tif ( hasOptions ) data = data.value;\n\t\t\t\tif (F.is.hash(this.value)){\n\t\t\t\t\tfor (var prop in data) {\n\t\t\t\t\t\tif (!data.hasOwnProperty(prop)) continue;\n\t\t\t\t\t\tthis.value[prop] = data[prop];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.value = data;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.value = null;\n\t\t\t}\n\n\t\t\tredrawSelf = F.is.boolean(redrawSelf) ? redrawSelf : true;\n\t\t\tF.arr.each(this.cells, function(cell){\n\t\t\t\tif (!cell.column.internal && F.is.defined(self.value[cell.column.name])){\n\t\t\t\t\tcell.val(self.value[cell.column.name], false, redrawSelf);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (this.created && redrawSelf){\n\t\t\t\tthis._setClasses(this.$el);\n\t\t\t\tthis._setStyle(this.$el);\n\t\t\t\tif (F.is.boolean(redraw) ? redraw : true) this.draw();\n\t\t\t}\n\t\t},\n\t\t_setClasses: function($el){\n\t\t\tvar hasClasses = !F.is.emptyArray(this.classes),\n\t\t\t\tclasses = null;\n\t\t\t$el.removeAttr('class');\n\t\t\tif (!hasClasses) return;\n\t\t\telse classes = this.classes.join(' ');\n\t\t\tif (!F.is.emptyString(classes)){\n\t\t\t\t$el.addClass(classes);\n\t\t\t}\n\t\t},\n\t\t_setStyle: function($el){\n\t\t\tvar hasStyle = !F.is.emptyObject(this.style),\n\t\t\t\tstyle = null;\n\t\t\t$el.removeAttr('style');\n\t\t\tif (!hasStyle) return;\n\t\t\telse style = this.style;\n\t\t\tif (F.is.hash(style)){\n\t\t\t\t$el.css(style);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets the current row to an expanded state displaying any hidden columns in a detail row just below it.\n\t\t * @instance\n\t\t * @fires FooTable.Row#\"expand.ft.row\"\n\t\t */\n\t\texpand: function(){\n\t\t\tif (!this.created) return;\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The expand.ft.row event is raised before the the row is expanded.\n\t\t\t * Calling preventDefault on this event will stop the row being expanded.\n\t\t\t * @event FooTable.Row#\"expand.ft.row\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {FooTable.Row} row - The row about to be expanded.\n\t\t\t */\n\t\t\tself.ft.raise('expand.ft.row',[self]).then(function(){\n\t\t\t\tself.__hidden__ = F.arr.map(self.cells, function(cell){\n\t\t\t\t\treturn cell.column.hidden && cell.column.visible ? cell : null;\n\t\t\t\t});\n\n\t\t\t\tif (self.__hidden__.length > 0){\n\t\t\t\t\tself.$details.insertAfter(self.$el)\n\t\t\t\t\t\t.children('td').first()\n\t\t\t\t\t\t.attr('colspan', self.ft.columns.visibleColspan);\n\n\t\t\t\t\tF.arr.each(self.__hidden__, function(cell){\n\t\t\t\t\t\tcell.collapse();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tself.$el.attr('data-expanded', true);\n\t\t\t\tself.$toggle.removeClass('ion-md-add').addClass('ion-md-remove');\n\t\t\t\tself.expanded = true;\n\t\t\t\tself.ft.raise('expanded.ft.row', [self]);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Sets the current row to a collapsed state removing the detail row if it exists.\n\t\t * @instance\n\t\t * @param {boolean} [setExpanded] - Whether or not to set the {@link FooTable.Row#expanded} property to false.\n\t\t * @fires FooTable.Row#\"collapse.ft.row\"\n\t\t */\n\t\tcollapse: function(setExpanded){\n\t\t\tif (!this.created) return;\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The collapse.ft.row event is raised before the the row is collapsed.\n\t\t\t * Calling preventDefault on this event will stop the row being collapsed.\n\t\t\t * @event FooTable.Row#\"collapse.ft.row\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {FooTable.Row} row - The row about to be expanded.\n\t\t\t */\n\t\t\tself.ft.raise('collapse.ft.row',[self]).then(function(){\n\t\t\t\tF.arr.each(self.__hidden__, function(cell){\n\t\t\t\t\tcell.restore();\n\t\t\t\t});\n\t\t\t\tself.$details.detach();\n\t\t\t\tself.$el.removeAttr('data-expanded');\n\t\t\t\tself.$toggle.removeClass('ion-md-remove').addClass('ion-md-add');\n\t\t\t\tif (F.is.boolean(setExpanded) ? setExpanded : true) self.expanded = false;\n\t\t\t\tself.ft.raise('collapsed.ft.row', [self]);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Prior to drawing this moves the details contents back to there original cells and detaches the toggle element from the row.\n\t\t * @instance\n\t\t * @param {boolean} [detach] - Whether or not to detach the row.\n\t\t * @this FooTable.Row\n\t\t */\n\t\tpredraw: function(detach){\n\t\t\tif (this.created){\n\t\t\t\tif (this.expanded){\n\t\t\t\t\tthis.collapse(false);\n\t\t\t\t}\n\t\t\t\tthis.$toggle.detach();\n\t\t\t\tdetach = F.is.boolean(detach) ? detach : true;\n\t\t\t\tif (detach) this.$el.detach();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Draws the current row and cells.\n\t\t * @instance\n\t\t * @this FooTable.Row\n\t\t */\n\t\tdraw: function($parent){\n\t\t\tif (!this.created) this.$create();\n\t\t\tif (F.is.jq($parent)) $parent.append(this.$el);\n\t\t\tvar self = this;\n\t\t\tF.arr.each(self.cells, function(cell){\n\t\t\t\tcell.$el.css('display', (cell.column.hidden || !cell.column.visible  ? 'none' : 'table-cell'));\n\t\t\t\tif (self.ft.rows.showToggle && self.ft.columns.hasHidden){\n\t\t\t\t\tif ((self.ft.rows.toggleColumn == 'first' && cell.column.index == self.ft.columns.firstVisibleIndex)\n\t\t\t\t\t\t|| (self.ft.rows.toggleColumn == 'last' && cell.column.index == self.ft.columns.lastVisibleIndex)) {\n\t\t\t\t\t\tcell.$el.prepend(self.$toggle);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcell.$el.add(cell.column.$el).removeClass('footable-first-visible footable-last-visible');\n\t\t\t\tif (cell.column.index == self.ft.columns.firstVisibleIndex){\n\t\t\t\t\tcell.$el.add(cell.column.$el).addClass('footable-first-visible');\n\t\t\t\t}\n\t\t\t\tif (cell.column.index == self.ft.columns.lastVisibleIndex){\n\t\t\t\t\tcell.$el.add(cell.column.$el).addClass('footable-last-visible');\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (this.expanded){\n\t\t\t\tthis.expand();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Toggles the row between it's expanded and collapsed state if there are hidden columns.\n\t\t * @instance\n\t\t * @this FooTable.Row\n\t\t */\n\t\ttoggle: function(){\n\t\t\tif (this.created && this.ft.columns.hasHidden){\n\t\t\t\tif (this.expanded) this.collapse();\n\t\t\t\telse this.expand();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the toggle click event for rows.\n\t\t * @instance\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the click event.\n\t\t * @private\n\t\t * @this jQuery\n\t\t */\n\t\t_onToggle: function (e) {\n\t\t\tvar self = e.data.self;\n\t\t\t// only execute the toggle if the event.target is one of the approved initiators\n\t\t\tif ($(e.target).is(self.ft.rows.toggleSelector)){\n\t\t\t\tself.toggle();\n\t\t\t}\n\t\t}\n\t});\n\n})(jQuery, FooTable);\n\n(function ($, F) {\n\n\t/**\n\t * An array of all currently loaded instances of the plugin.\n\t * @protected\n\t * @readonly\n\t * @type {Array.<FooTable.Table>}\n\t */\n\tF.instances = [];\n\n\tF.Table = F.Class.extend(/** @lends FooTable.Table */{\n\t\t/**\n\t\t * This class is the core of the plugin and drives the logic of all components.\n\t\t * @constructs\n\t\t * @this FooTable.Table\n\t\t * @extends FooTable.Class\n\t\t * @param {(HTMLTableElement|jQuery)} element - The element or jQuery table object to bind the plugin to.\n\t\t * @param {object} options - The options to initialize the plugin with.\n\t\t * @param {function} [ready] - A callback function to execute once the plugin is initialized.\n\t\t * @returns {FooTable.Table}\n\t\t */\n\t\tconstruct: function (element, options, ready) {\n\t\t\t//BEGIN MEMBERS\n\t\t\t/**\n\t\t\t * The timeout ID for the resize event.\n\t\t\t * @instance\n\t\t\t * @private\n\t\t\t * @type {?number}\n\t\t\t */\n\t\t\tthis._resizeTimeout = null;\n\t\t\t/**\n\t\t\t * The ID of the FooTable instance.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.id = F.instances.push(this);\n\t\t\t/**\n\t\t\t * Whether or not the plugin and all components and add-ons are fully initialized.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.initialized = false;\n\t\t\t/**\n\t\t\t * The jQuery table object the plugin is bound to.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$el = (F.is.jq(element) ? element : $(element)).first(); // ensure one table, one instance\n\t\t\t/**\n\t\t\t * A loader jQuery instance\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$loader = $('<div/>', { 'class': 'footable-loader' }).append($('<i/>', {'class': 'icon ion-md-refresh'}));\n\t\t\t/**\n\t\t\t * The options for the plugin. This is a merge of user defined options and the default options.\n\t\t\t * @instance\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.o = $.extend(true, {}, F.defaults, options);\n\t\t\t/**\n\t\t\t * The jQuery data object for the table at initialization.\n\t\t\t * @instance\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.data = this.$el.data() || {};\n\t\t\t/**\n\t\t\t * An array of all CSS classes on the table that do not start with \"footable\".\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {Array.<string>}\n\t\t\t */\n\t\t\tthis.classes = [];\n\t\t\t/**\n\t\t\t * All components for this instance of the plugin. These are executed in the order they appear in the array for the initialize phase and in reverse order for the destroy phase of the plugin.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {object}\n\t\t\t * @prop {Array.<FooTable.Component>} internal - The internal components for the plugin. These are executed either before all other components in the initialize phase or after them in the destroy phase of the plugin.\n\t\t\t * @prop {Array.<FooTable.Component>} core - The core components for the plugin. These are executed either after the internal components in the initialize phase or before them in the destroy phase of the plugin.\n\t\t\t * @prop {Array.<FooTable.Component>} custom - The custom components for the plugin. These are executed either after the core components in the initialize phase or before them in the destroy phase of the plugin.\n\t\t\t */\n\t\t\tthis.components = F.components.load((F.is.hash(this.data.components) ? this.data.components : this.o.components), this);\n\t\t\t/**\n\t\t\t * The breakpoints component for this instance of the plugin.\n\t\t\t * @instance\n\t\t\t * @type {FooTable.Breakpoints}\n\t\t\t */\n\t\t\tthis.breakpoints = this.use(FooTable.Breakpoints);\n\t\t\t/**\n\t\t\t * The columns component for this instance of the plugin.\n\t\t\t * @instance\n\t\t\t * @type {FooTable.Columns}\n\t\t\t */\n\t\t\tthis.columns = this.use(FooTable.Columns);\n\t\t\t/**\n\t\t\t * The rows component for this instance of the plugin.\n\t\t\t * @instance\n\t\t\t * @type {FooTable.Rows}\n\t\t\t */\n\t\t\tthis.rows = this.use(FooTable.Rows);\n\n\t\t\t//END MEMBERS\n\t\t\tthis._construct(ready);\n\t\t},\n\t\t/**\n\t\t * Once all properties are set this performs the actual initialization of the plugin calling the {@link FooTable.Table#_preinit} and\n\t\t * {@link FooTable.Table#_init} methods as well as raising the {@link FooTable.Table#\"ready.ft.table\"} event.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @param {function} [ready] - A callback function to execute once the plugin is initialized.\n\t\t * @private\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Table#\"ready.ft.table\"\n\t\t */\n\t\t_construct: function(ready){\n\t\t\tvar self = this;\n\t\t\treturn this._preinit().then(function(){\n\t\t\t\treturn self._init().then(function(){\n\t\t\t\t\t/**\n\t\t\t\t\t * The ready.ft.table event is raised after the plugin has been initialized and the table drawn.\n\t\t\t\t\t * Calling preventDefault on this event will stop the ready callback being executed.\n\t\t\t\t\t * @event FooTable.Table#\"ready.ft.table\"\n\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t */\n\t\t\t\t\treturn self.raise('ready.ft.table').then(function(){\n\t\t\t\t\t\tif (F.is.fn(ready)) ready.call(self, self);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}).always(function(arg){\n\t\t\t\tself.$el.show();\n\t\t\t\tif (F.is.error(arg)){\n\t\t\t\t\tconsole.error('FooTable: unhandled error thrown during initialization.', arg);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * The preinit method is called prior to the plugins actual initialization and provides itself and it's components an opportunity to parse any additional option values.\n\t\t * @instance\n\t\t * @private\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Table#\"preinit.ft.table\"\n\t\t */\n\t\t_preinit: function(){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.table event is raised before any components.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Table#\"preinit.ft.table\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object from the root table element.\n\t\t\t */\n\t\t\treturn this.raise('preinit.ft.table', [self.data]).then(function(){\n\t\t\t\tvar classes = (self.$el.attr('class') || '').match(/\\S+/g) || [];\n\n\t\t\t\tself.o.ajax = F.checkFnValue(self, self.data.ajax, self.o.ajax);\n\t\t\t\tself.o.stopPropagation = F.is.boolean(self.data.stopPropagation)\n\t\t\t\t\t? self.data.stopPropagation\n\t\t\t\t\t: self.o.stopPropagation;\n\n\t\t\t\tfor (var i = 0, len = classes.length; i < len; i++){\n\t\t\t\t\tif (!F.str.startsWith(classes[i], 'footable')) self.classes.push(classes[i]);\n\t\t\t\t}\n\n\t\t\t\tself.$el.hide().after(self.$loader);\n\t\t\t\treturn self.execute(false, false, 'preinit', self.data);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes this instance of the plugin and calls the callback function if one is supplied once complete.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @private\n\t\t * @return {jQuery.Promise}\n\t\t * @fires FooTable.Table#\"init.ft.table\"\n\t\t */\n\t\t_init: function(){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The init.ft.table event is raised before any components are initialized.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Table#\"init.ft.table\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\treturn self.raise('init.ft.table').then(function(){\n\t\t\t\tvar $thead = self.$el.children('thead'),\n\t\t\t\t\t$tbody = self.$el.children('tbody'),\n\t\t\t\t\t$tfoot = self.$el.children('tfoot');\n\t\t\t\tself.$el.addClass('footable footable-' + self.id);\n\t\t\t\tif (F.is.hash(self.o.on)) self.$el.on(self.o.on);\n\t\t\t\tif ($tfoot.length == 0) self.$el.append($tfoot = $('<tfoot/>'));\n\t\t\t\tif ($tbody.length == 0) self.$el.append('<tbody/>');\n\t\t\t\tif ($thead.length == 0) self.$el.prepend($thead = $('<thead/>'));\n\t\t\t\treturn self.execute(false, true, 'init').then(function(){\n\t\t\t\t\tself.$el.data('__FooTable__', self);\n\t\t\t\t\tif ($tfoot.children('tr').length == 0) $tfoot.remove();\n\t\t\t\t\tif ($thead.children('tr').length == 0) $thead.remove();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * The postinit.ft.table event is raised after any components are initialized but before the table is\n\t\t\t\t\t * drawn for the first time.\n\t\t\t\t\t * Calling preventDefault on this event will disable the initial drawing of the table.\n\t\t\t\t\t * @event FooTable.Table#\"postinit.ft.table\"\n\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t */\n\t\t\t\t\treturn self.raise('postinit.ft.table').then(function(){\n\t\t\t\t\t\treturn self.draw();\n\t\t\t\t\t}).always(function(){\n\t\t\t\t\t\t$(window).off('resize.ft'+self.id, self._onWindowResize)\n\t\t\t\t\t\t\t.on('resize.ft'+self.id, { self: self }, self._onWindowResize);\n\t\t\t\t\t\tself.initialized = true;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys this plugin removing it from the table.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @fires FooTable.Table#\"destroy.ft.table\"\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The destroy.ft.table event is called before all core components.\n\t\t\t * Calling preventDefault on this event will prevent the entire plugin from being destroyed.\n\t\t\t * @event FooTable.Table#\"destroy.ft.table\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\treturn self.raise('destroy.ft.table').then(function(){\n\t\t\t\treturn self.execute(true, true, 'destroy').then(function () {\n\t\t\t\t\tself.$el.removeData('__FooTable__').removeClass('footable-' + self.id);\n\t\t\t\t\tif (F.is.hash(self.o.on)) self.$el.off(self.o.on);\n\t\t\t\t\t$(window).off('resize.ft'+self.id, self._onWindowResize);\n\t\t\t\t\tself.initialized = false;\n\t\t\t\t\tF.instances[self.id] = null;\n\t\t\t\t});\n\t\t\t}).fail(function(err){\n\t\t\t\tif (F.is.error(err)){\n\t\t\t\t\tconsole.error('FooTable: unhandled error thrown while destroying the plugin.', err);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Raises an event on this instance supplying the args array as additional parameters to the handlers.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @param {string} eventName - The name of the event to raise, this can include namespaces.\n\t\t * @param {Array} [args] - An array containing additional parameters to be passed to any bound handlers.\n\t\t * @returns {jQuery.Event}\n\t\t */\n\t\traise: function(eventName, args){\n\t\t\tvar self = this,\n\t\t\t\tdebug = F.__debug__ && (F.is.emptyArray(F.__debug_options__.events) || F.arr.any(F.__debug_options__.events, function(name){ return F.str.contains(eventName, name); }));\n\t\t\targs = args || [];\n\t\t\targs.unshift(this);\n\t\t\treturn $.Deferred(function(d){\n\t\t\t\tvar evt = $.Event(eventName);\n\t\t\t\tif (self.o.stopPropagation == true){\n\t\t\t\t\tself.$el.one(eventName, function (e) {e.stopPropagation();});\n\t\t\t\t}\n\t\t\t\tif (debug) console.log('FooTable:'+eventName+': ', args);\n\t\t\t\tself.$el.trigger(evt, args);\n\t\t\t\tif (evt.isDefaultPrevented()){\n\t\t\t\t\tif (debug) console.log('FooTable: default prevented for the \"'+eventName+'\" event.');\n\t\t\t\t\td.reject(evt);\n\t\t\t\t}\telse d.resolve(evt);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Attempts to retrieve the instance of the supplied component type for this instance.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @param {object} type - The content type to retrieve for this instance.\n\t\t * @returns {(*|null)}\n\t\t */\n\t\tuse: function(type){\n\t\t\tfor (var i = 0, len = this.components.length; i < len; i++){\n\t\t\t\tif (this.components[i] instanceof type) return this.components[i];\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Performs the drawing of the table.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Table#\"predraw.ft.table\"\n\t\t * @fires FooTable.Table#\"draw.ft.table\"\n\t\t * @fires FooTable.Table#\"postdraw.ft.table\"\n\t\t */\n\t\tdraw: function () {\n\t\t\tvar self = this;\n\n\t\t\t// Clone the current table and insert it into the original's place\n\t\t\tvar $elCopy = self.$el.clone().insertBefore(self.$el);\n\n\t\t\t// Detach `self.$el` from the DOM, retaining its event handlers\n\t\t\tself.$el.detach();\n\n\t\t\t// when drawing the order that the components are executed is important so chain the methods but use promises to retain async safety.\n\t\t\treturn self.execute(false, true, 'predraw').then(function(){\n\t\t\t\t/**\n\t\t\t\t * The predraw.ft.table event is raised after all core components and add-ons have executed there predraw functions but before they execute there draw functions.\n\t\t\t\t * @event FooTable.Table#\"predraw.ft.table\"\n\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t */\n\t\t\t\treturn self.raise('predraw.ft.table').then(function(){\n\t\t\t\t\treturn self.execute(false, true, 'draw').then(function(){\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * The draw.ft.table event is raised after all core components and add-ons have executed there draw functions.\n\t\t\t\t\t\t * @event FooTable.Table#\"draw.ft.table\"\n\t\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn self.raise('draw.ft.table').then(function(){\n\t\t\t\t\t\t\treturn self.execute(false, true, 'postdraw').then(function(){\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * The postdraw.ft.table event is raised after all core components and add-ons have executed there postdraw functions.\n\t\t\t\t\t\t\t\t * @event FooTable.Table#\"postdraw.ft.table\"\n\t\t\t\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\treturn self.raise('postdraw.ft.table');\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}).fail(function(err){\n\t\t\t\tif (F.is.error(err)){\n\t\t\t\t\tconsole.error('FooTable: unhandled error thrown during a draw operation.', err);\n\t\t\t\t}\n\t\t\t}).always(function(){\n\t\t\t\t// Replace the copy that we added above with the modified `self.$el`\n\t\t\t\t$elCopy.replaceWith(self.$el);\n\t\t\t\tself.$loader.remove();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Executes the specified method with the optional number of parameters on all components and waits for the promise from each to be resolved before executing the next.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {boolean} reverse - Whether or not to execute the component methods in the reverse order to what they were registered in.\n\t\t * @param {boolean} enabled - Whether or not to execute the method on enabled components only.\n\t\t * @param {string} methodName - The name of the method to execute.\n\t\t * @param {*} [param1] - The first parameter for the method.\n\t\t * @param {...*} [paramN] - Any number of additional parameters for the method.\n\t\t * @returns {jQuery.Promise}\n\t\t */\n\t\texecute: function(reverse, enabled, methodName, param1, paramN){\n\t\t\tvar self = this, args = Array.prototype.slice.call(arguments);\n\t\t\treverse = args.shift();\n\t\t\tenabled = args.shift();\n\t\t\tvar components = enabled ? F.arr.get(self.components, function(c){ return c.enabled; }) : self.components.slice(0);\n\t\t\targs.unshift(reverse ? components.reverse() : components);\n\t\t\treturn self._execute.apply(self, args);\n\t\t},\n\t\t/**\n\t\t * Executes the specified method with the optional number of parameters on all supplied components waiting for the result of each before executing the next.\n\t\t * @this FooTable.Table\n\t\t * @instance\n\t\t * @private\n\t\t * @param {Array.<FooTable.Component>} components - The components to call the method on.\n\t\t * @param {string} methodName - The name of the method to execute\n\t\t * @param {*} [param1] - The first parameter for the method.\n\t\t * @param {...*} [paramN] - Any additional parameters for the method.\n\t\t * @returns {jQuery.Promise}\n\t\t */\n\t\t_execute: function(components, methodName, param1, paramN){\n\t\t\tif (!components || !components.length) return $.when();\n\t\t\tvar self = this, args = Array.prototype.slice.call(arguments),\n\t\t\t\tcomponent;\n\t\t\tcomponents = args.shift();\n\t\t\tmethodName = args.shift();\n\t\t\tcomponent = components.shift();\n\n\t\t\tif (!F.is.fn(component[methodName]))\n\t\t\t\treturn self._execute.apply(self, [components, methodName].concat(args));\n\n\t\t\treturn $.Deferred(function(d){\n\t\t\t\ttry {\n\t\t\t\t\tvar result = component[methodName].apply(component, args);\n\t\t\t\t\tif (F.is.promise(result)){\n\t\t\t\t\t\treturn result.then(d.resolve, d.reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\td.resolve(result);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\td.reject(err);\n\t\t\t\t}\n\t\t\t}).then(function(){\n\t\t\t\treturn self._execute.apply(self, [components, methodName].concat(args));\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Listens to the window resize event and performs a check to see if the breakpoint has changed.\n\t\t * @this window\n\t\t * @instance\n\t\t * @private\n\t\t * @fires FooTable.Table#\"resize.ft.table\"\n\t\t */\n\t\t_onWindowResize: function (e) {\n\t\t\tvar self = e.data.self;\n\t\t\tif (self._resizeTimeout != null) { clearTimeout(self._resizeTimeout); }\n\t\t\tself._resizeTimeout = setTimeout(function () {\n\t\t\t\tself._resizeTimeout = null;\n\t\t\t\t/**\n\t\t\t\t * The resize event is raised a short time after window resize operations cease.\n\t\t\t\t * @event FooTable.Table#\"resize.ft.table\"\n\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t */\n\t\t\t\tself.raise('resize.ft.table').then(function(){\n\t\t\t\t\tself.breakpoints.check();\n\t\t\t\t});\n\t\t\t}, 300);\n\t\t}\n\t});\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.ArrayColumn = F.Column.extend(/** @lends FooTable.ArrayColumn */{\n\t\t/**\n\t\t * @summary A column to handle Array values.\n\t\t * @constructs\n\t\t * @extends FooTable.Column\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this column belongs to.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t */\n\t\tconstruct: function(instance, definition) {\n\t\t\tthis._super(instance, definition, 'array');\n\t\t},\n\t\t/**\n\t\t * @summary Parses the supplied value or element to retrieve a column value.\n\t\t * @description This is supplied either the cell value or jQuery object to parse. This method will return either the Array containing the values or null.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {(array|null)}\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){ // use jQuery to get the value\n\t\t\t\tvar $el = $(valueOrElement), data = $el.data('value'); // .data() will automatically convert a JSON string to an array\n\t\t\t\tif (F.is.array(data)) return data;\n\t\t\t\tdata = $el.html();\n\t\t\t\ttry {\n\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t} catch(err) {\n\t\t\t\t\tdata = null;\n\t\t\t\t}\n\t\t\t\treturn F.is.array(data) ? data : null; // if we have an array return it\n\t\t\t}\n\t\t\tif (F.is.array(valueOrElement)) return valueOrElement; // if we have an array return it\n\t\t\treturn null; // otherwise we have no value so return null\n\t\t},\n\t\t/**\n\t\t * @summary Formats the column value and creates the HTML seen within a cell.\n\t\t * @description This is supplied the value retrieved from the {@link FooTable.ArrayColumn#parser} function and must return a string, HTMLElement or jQuery object.\n\t\t * The return value from this function is what is displayed in the cell in the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {?Array} value - The value to format.\n\t\t * @param {object} options - The current plugin options.\n\t\t * @param {object} rowData - An object containing the current row data.\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\tformatter: function(value, options, rowData){\n\t\t\treturn F.is.array(value) ? JSON.stringify(value) : '';\n\t\t}\n\t});\n\n\tF.columns.register('array', F.ArrayColumn);\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tif (F.is.undef(window.moment)){\n\t\t// The DateColumn requires moment.js to parse and format date values. Goto http://momentjs.com/ to get it.\n\t\treturn;\n\t}\n\n\tF.DateColumn = F.Column.extend(/** @lends FooTable.DateColumn */{\n\t\t/**\n\t\t * The date column class is used to handle date values. This column is dependent on [moment.js]{@link http://momentjs.com/} to provide date parsing and formatting functionality.\n\t\t * @constructs\n\t\t * @extends FooTable.Column\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this column belongs to.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t * @returns {FooTable.DateColumn}\n\t\t */\n\t\tconstruct: function(instance, definition){\n\t\t\tthis._super(instance, definition, 'date');\n\t\t\t/**\n\t\t\t * The format string to use when parsing and formatting dates.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.formatString = F.is.string(definition.formatString) ? definition.formatString : 'MM-DD-YYYY';\n\t\t},\n\t\t/**\n\t\t * This is supplied either the cell value or jQuery object to parse. Any value can be returned from this method and will be provided to the {@link FooTable.DateColumn#format} function\n\t\t * to generate the cell contents.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {(moment|null)}\n\t\t * @this FooTable.DateColumn\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){\n\t\t\t\tvar data = $(valueOrElement).data('value');\n\t\t\t\tvalueOrElement = F.is.defined(data) ? data : $(valueOrElement).text();\n\t\t\t\tif (F.is.string(valueOrElement)) valueOrElement = isNaN(valueOrElement) ? valueOrElement : +valueOrElement;\n\t\t\t}\n\t\t\tif (F.is.date(valueOrElement)) return moment(valueOrElement);\n\t\t\tif (F.is.object(valueOrElement) && F.is.boolean(valueOrElement._isAMomentObject)) return valueOrElement;\n\t\t\tif (F.is.string(valueOrElement)){\n\t\t\t\t// if it looks like a number convert it and do nothing else otherwise create a new moment using the string value and formatString\n\t\t\t\tif (isNaN(valueOrElement)){\n\t\t\t\t\treturn moment(valueOrElement, this.formatString);\n\t\t\t\t} else {\n\t\t\t\t\tvalueOrElement = +valueOrElement;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (F.is.number(valueOrElement)){\n\t\t\t\treturn moment(valueOrElement);\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * This is supplied the value retrieved from the {@link FooTable.DateColumn#parser} function and must return a string, HTMLElement or jQuery object.\n\t\t * The return value from this function is what is displayed in the cell in the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {*} value - The value to format.\n\t\t * @param {object} options - The current plugin options.\n\t\t * @param {object} rowData - An object containing the current row data.\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t * @this FooTable.DateColumn\n\t\t */\n\t\tformatter: function(value, options, rowData){\n\t\t\treturn F.is.object(value) && F.is.boolean(value._isAMomentObject) && value.isValid() ? value.format(this.formatString) : '';\n\t\t},\n\t\t/**\n\t\t * This is supplied either the cell value or jQuery object to parse. A string value must be returned from this method and will be used during filtering operations.\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {string}\n\t\t * @this FooTable.DateColumn\n\t\t */\n\t\tfilterValue: function(valueOrElement){\n\t\t\t// if we have an element or a jQuery object use jQuery to get the value\n\t\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)) valueOrElement = $(valueOrElement).data('filterValue') || $(valueOrElement).text();\n\t\t\t// if options are supplied with the value\n\t\t\tif (F.is.hash(valueOrElement) && F.is.hash(valueOrElement.options)){\n\t\t\t\tif (F.is.string(valueOrElement.options.filterValue)) valueOrElement = valueOrElement.options.filterValue;\n\t\t\t\tif (F.is.defined(valueOrElement.value)) valueOrElement = valueOrElement.value;\n\t\t\t}\n\t\t\t// if the value is a moment object just return the formatted value\n\t\t\tif (F.is.object(valueOrElement) && F.is.boolean(valueOrElement._isAMomentObject)) return valueOrElement.format(this.formatString);\n\t\t\t// if its a string\n\t\t\tif (F.is.string(valueOrElement)){\n\t\t\t\t// if its not a number return it\n\t\t\t\tif (isNaN(valueOrElement)){\n\t\t\t\t\treturn valueOrElement;\n\t\t\t\t} else { // otherwise convert it and carry on\n\t\t\t\t\tvalueOrElement = +valueOrElement;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if the value is a number or date convert to a moment object and return the formatted result.\n\t\t\tif (F.is.number(valueOrElement) || F.is.date(valueOrElement)){\n\t\t\t\treturn moment(valueOrElement).format(this.formatString);\n\t\t\t}\n\t\t\t// try use the native toString of the value if its not undefined or null\n\t\t\tif (F.is.defined(valueOrElement) && valueOrElement != null) return valueOrElement+'';\n\t\t\treturn ''; // otherwise we have no value so return an empty string\n\t\t}\n\t});\n\n\tF.columns.register('date', F.DateColumn);\n\n})(jQuery, FooTable);\n\n(function($, F){\n\n\tF.HTMLColumn = F.Column.extend(/** @lends FooTable.HTMLColumn */{\n\t\t/**\n\t\t * The HTML column class is used to handle any raw HTML columns.\n\t\t * @constructs\n\t\t * @extends FooTable.Column\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this column belongs to.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t * @returns {FooTable.HTMLColumn}\n\t\t */\n\t\tconstruct: function(instance, definition){\n\t\t\tthis._super(instance, definition, 'html');\n\t\t},\n\t\t/**\n\t\t * This is supplied either the cell value or jQuery object to parse. Any value can be returned from this method and will be provided to the {@link FooTable.HTMLColumn#format} function\n\t\t * to generate the cell contents.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {(jQuery|null)}\n\t\t * @this FooTable.HTMLColumn\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.string(valueOrElement)) valueOrElement = $($.trim(valueOrElement));\n\t\t\tif (F.is.element(valueOrElement)) valueOrElement = $(valueOrElement);\n\t\t\tif (F.is.jq(valueOrElement)){\n\t\t\t\tvar tagName = valueOrElement.prop('tagName').toLowerCase();\n\t\t\t\tif (tagName == 'td' || tagName == 'th'){\n\t\t\t\t\tvar data = valueOrElement.data('value');\n\t\t\t\t\treturn F.is.defined(data) ? data : valueOrElement.contents();\n\t\t\t\t}\n\t\t\t\treturn valueOrElement;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t});\n\n\tF.columns.register('html', F.HTMLColumn);\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.NumberColumn = F.Column.extend(/** @lends FooTable.NumberColumn */{\n\t\t/**\n\t\t * The number column class is used to handle simple number columns.\n\t\t * @constructs\n\t\t * @extends FooTable.Column\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this column belongs to.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t * @returns {FooTable.NumberColumn}\n\t\t */\n\t\tconstruct: function(instance, definition){\n\t\t\tthis._super(instance, definition, 'number');\n\t\t\tthis.decimalSeparator = F.is.string(definition.decimalSeparator) ? definition.decimalSeparator : '.';\n\t\t\tthis.thousandSeparator = F.is.string(definition.thousandSeparator) ? definition.thousandSeparator : ',';\n\t\t\tthis.decimalSeparatorRegex = new RegExp(F.str.escapeRegExp(this.decimalSeparator), 'g');\n\t\t\tthis.thousandSeparatorRegex = new RegExp(F.str.escapeRegExp(this.thousandSeparator), 'g');\n\t\t\tthis.cleanRegex = new RegExp('[^\\-0-9' + F.str.escapeRegExp(this.decimalSeparator) + ']', 'g');\n\t\t},\n\t\t/**\n\t\t * This is supplied either the cell value or jQuery object to parse. Any value can be returned from this method and will be provided to the {@link FooTable.Column#formatter} function\n\t\t * to generate the cell contents.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {(number|null)}\n\t\t * @this FooTable.NumberColumn\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){\n\t\t\t\tvar data = $(valueOrElement).data('value');\n\t\t\t\tvalueOrElement = F.is.defined(data) ? data : $(valueOrElement).text().replace(this.cleanRegex, '');\n\t\t\t}\n\t\t\tif (F.is.string(valueOrElement)){\n\t\t\t\tvalueOrElement = valueOrElement.replace(this.thousandSeparatorRegex, '').replace(this.decimalSeparatorRegex, '.');\n\t\t\t\tvalueOrElement = parseFloat(valueOrElement);\n\t\t\t}\n\t\t\tif (F.is.number(valueOrElement)) return valueOrElement;\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * This is supplied the value retrieved from the {@link FooTable.NumberColumn#parse} function and must return a string, HTMLElement or jQuery object.\n\t\t * The return value from this function is what is displayed in the cell in the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {number} value - The value to format.\n\t\t * @param {object} options - The current plugin options.\n\t\t * @param {object} rowData - An object containing the current row data.\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t * @this FooTable.NumberColumn\n\t\t */\n\t\tformatter: function(value, options, rowData){\n\t\t\tif (value == null) return '';\n\t\t\tvar s = (value + '').split('.');\n\t\t\tif (s.length == 2 && s[0].length > 3) {\n\t\t\t\ts[0] = s[0].replace(/\\B(?=(?:\\d{3})+(?!\\d))/g, this.thousandSeparator);\n\t\t\t}\n\t\t\treturn s.join(this.decimalSeparator);\n\t\t}\n\t});\n\n\tF.columns.register('number', F.NumberColumn);\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.ObjectColumn = F.Column.extend(/** @lends FooTable.ObjectColumn */{\n\t\t/**\n\t\t * @summary A column to handle Object values.\n\t\t * @constructs\n\t\t * @extends FooTable.Column\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this column belongs to.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t */\n\t\tconstruct: function(instance, definition) {\n\t\t\tthis._super(instance, definition, 'object');\n\t\t},\n\t\t/**\n\t\t * @summary Parses the supplied value or element to retrieve a column value.\n\t\t * @description This is supplied either the cell value or jQuery object to parse. This method will return either the Object containing the values or null.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {(object|null)}\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){ // use jQuery to get the value\n\t\t\t\tvar $el = $(valueOrElement), data = $el.data('value'); // .data() will automatically convert a JSON string to an object\n\t\t\t\tif (F.is.object(data)) return data;\n\t\t\t\tdata = $el.html();\n\t\t\t\ttry {\n\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t} catch(err) {\n\t\t\t\t\tdata = null;\n\t\t\t\t}\n\t\t\t\treturn F.is.object(data) ? data : null; // if we have an object return it\n\t\t\t}\n\t\t\tif (F.is.object(valueOrElement)) return valueOrElement; // if we have an object return it\n\t\t\treturn null; // otherwise we have no value so return null\n\t\t},\n\t\t/**\n\t\t * @summary Formats the column value and creates the HTML seen within a cell.\n\t\t * @description This is supplied the value retrieved from the {@link FooTable.ObjectColumn#parser} function and must return a string, HTMLElement or jQuery object.\n\t\t * The return value from this function is what is displayed in the cell in the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {*} value - The value to format.\n\t\t * @param {object} options - The current plugin options.\n\t\t * @param {object} rowData - An object containing the current row data.\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\tformatter: function(value, options, rowData){\n\t\t\treturn F.is.object(value) ? JSON.stringify(value) : '';\n\t\t}\n\t});\n\n\tF.columns.register('object', F.ObjectColumn);\n\n})(jQuery, FooTable);\n(function($, F){\n\n\tF.Breakpoint = F.Class.extend(/** @lends FooTable.Breakpoint */{\n\t\t/**\n\t\t * The breakpoint class containing the name and maximum width for the breakpoint.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {string} name - The name of the breakpoint. Must contain no spaces or special characters.\n\t\t * @param {number} width - The width of the breakpoint in pixels.\n\t\t * @returns {FooTable.Breakpoint}\n\t\t */\n\t\tconstruct: function(name, width){\n\t\t\t/**\n\t\t\t * The name of the breakpoint.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.name = name;\n\t\t\t/**\n\t\t\t * The maximum width of the breakpoint in pixels.\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.width = width;\n\t\t}\n\t});\n\n})(jQuery, FooTable);\n(function($, F){\n\tF.Breakpoints = F.Component.extend(/** @lends FooTable.Breakpoints */{\n\t\t/**\n\t\t * Contains the logic to calculate and apply breakpoints for the plugin.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table -  The parent {@link FooTable.Table} this component belongs to.\n\t\t * @returns {FooTable.Breakpoints}\n\t\t */\n\t\tconstruct: function(table){\n\t\t\t// call the base class constructor\n\t\t\tthis._super(table, true);\n\n\t\t\t/* PROTECTED */\n\t\t\t/**\n\t\t\t * This provides a shortcut to the {@link FooTable.Table#options} object.\n\t\t\t * @protected\n\t\t\t * @type {FooTable.Table#options}\n\t\t\t */\n\t\t\tthis.o = table.o;\n\n\t\t\t/* PUBLIC */\n\t\t\t/**\n\t\t\t * The current breakpoint.\n\t\t\t * @type {FooTable.Breakpoint}\n\t\t\t */\n\t\t\tthis.current = null;\n\t\t\t/**\n\t\t\t * An array of {@link FooTable.Breakpoint} objects created from parsing the options.\n\t\t\t * @type {Array.<FooTable.Breakpoint>}\n\t\t\t */\n\t\t\tthis.array = [];\n\t\t\t/**\n\t\t\t * Whether or not breakpoints cascade. When set to true all breakpoints larger than the current will be hidden along with it.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.cascade = this.o.cascade;\n\t\t\t/**\n\t\t\t * Whether or not to calculate breakpoints on the width of the parent element rather than the viewport.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.useParentWidth = this.o.useParentWidth;\n\t\t\t/**\n\t\t\t * This value is updated each time the current breakpoint changes and contains a space delimited string of the names of the current breakpoint and all those smaller than it.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.hidden = null;\n\n\t\t\t/* PRIVATE */\n\t\t\t/**\n\t\t\t * This value is set once when the {@link FooTable.Breakpoints#array} is generated and contains a space delimited string of all the breakpoint class names.\n\t\t\t * @type {string}\n\t\t\t * @private\n\t\t\t */\n\t\t\tthis._classNames = '';\n\n\t\t\t// check if a function was supplied to override the default getWidth\n\t\t\tthis.getWidth = F.checkFnValue(this, this.o.getWidth, this.getWidth);\n\t\t},\n\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * Checks the supplied data and options for the breakpoints component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the parent table.\n\t\t * @fires FooTable.Breakpoints#\"preinit.ft.breakpoints\"\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.breakpoints event is raised before any UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Breakpoints#\"preinit.ft.breakpoints\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\treturn this.ft.raise('preinit.ft.breakpoints', [data]).then(function(){\n\t\t\t\tself.cascade = F.is.boolean(data.cascade) ? data.cascade : self.cascade;\n\t\t\t\tself.o.breakpoints = F.is.hash(data.breakpoints) ? data.breakpoints : self.o.breakpoints;\n\t\t\t\tself.getWidth = F.checkFnValue(self, data.getWidth, self.getWidth);\n\t\t\t\tif (self.o.breakpoints == null) self.o.breakpoints = { \"xs\": 480, \"sm\": 768, \"md\": 992, \"lg\": 1200 };\n\t\t\t\t// Create a nice friendly array to work with out of the breakpoints object.\n\t\t\t\tfor (var name in self.o.breakpoints) {\n\t\t\t\t\tif (!self.o.breakpoints.hasOwnProperty(name)) continue;\n\t\t\t\t\tself.array.push(new F.Breakpoint(name, self.o.breakpoints[name]));\n\t\t\t\t\tself._classNames += 'breakpoint-' + name + ' ';\n\t\t\t\t}\n\t\t\t\t// Sort the breakpoints so the largest is checked first\n\t\t\t\tself.array.sort(function (a, b) {\n\t\t\t\t\treturn b.width - a.width;\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the class parsing the options into a sorted array of {@link FooTable.Breakpoint} objects.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Breakpoints#\"init.ft.breakpoints\"\n\t\t */\n\t\tinit: function(){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The init.ft.breakpoints event is raised before any UI is generated.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Breakpoints#\"init.ft.breakpoints\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\treturn this.ft.raise('init.ft.breakpoints').then(function(){\n\t\t\t\tself.current = self.get();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Whenever the table is drawn this ensures the correct breakpoint class is applied to the table.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tdraw: function(){\n\t\t\tthis.ft.$el.removeClass(this._classNames).addClass('breakpoint-' + this.current.name);\n\t\t},\n\n\t\t/* PUBLIC */\n\t\t/**\n\t\t * Calculates the current breakpoint from the {@link FooTable.Breakpoints#array} and sets the {@link FooTable.Breakpoints#current} property.\n\t\t * @instance\n\t\t * @returns {FooTable.Breakpoint}\n\t\t */\n\t\tcalculate: function(){\n\t\t\tvar self = this, current = null, hidden = [], breakpoint, prev = null, width = self.getWidth();\n\t\t\tfor (var i = 0, len = self.array.length; i < len; i++) {\n\t\t\t\tbreakpoint = self.array[i];\n\t\t\t\t// if the width is smaller than the smallest breakpoint set the smallest as the current.\n\t\t\t\t// if the width is larger than the largest breakpoint set the largest as the current.\n\t\t\t\t// otherwise if the width is somewhere in between check all breakpoints testing if the width\n\t\t\t\t// is greater than the current but smaller than the previous.\n\t\t\t\tif ((!current && i == len -1)\n\t\t\t\t\t|| (width >= breakpoint.width && (prev instanceof F.Breakpoint ? width < prev.width : true))) {\n\t\t\t\t\tcurrent = breakpoint;\n\t\t\t\t}\n\t\t\t\tif (!current) hidden.push(breakpoint.name);\n\t\t\t\tprev = breakpoint;\n\t\t\t}\n\t\t\thidden.push(current.name);\n\t\t\tself.hidden = hidden.join(' ');\n\t\t\treturn current;\n\t\t},\n\t\t/**\n\t\t * Supplied a columns breakpoints this returns a boolean value indicating whether or not the column is visible.\n\t\t * @param {string} breakpoints - A space separated string of breakpoint names.\n\t\t * @returns {boolean}\n\t\t */\n\t\tvisible: function(breakpoints){\n\t\t\tif (F.is.emptyString(breakpoints)) return true;\n\t\t\tif (breakpoints === 'all') return false;\n\t\t\tvar parts = breakpoints.split(' '), i = 0, len = parts.length;\n\t\t\tfor (; i < len; i++){\n\t\t\t\tif (this.cascade ? F.str.containsWord(this.hidden, parts[i]) : parts[i] == this.current.name) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t * Performs a check between the current breakpoint and the previous breakpoint and performs a redraw if they differ.\n\t\t * @instance\n\t\t * @fires FooTable.Breakpoints#\"before.ft.breakpoints\"\n\t\t * @fires FooTable.Breakpoints#\"after.ft.breakpoints\"\n\t\t */\n\t\tcheck: function(){\n\t\t\tvar self = this, bp = self.get();\n\t\t\tif (!(bp instanceof F.Breakpoint)\n\t\t\t\t|| bp == self.current)\n\t\t\t\treturn;\n\n\t\t\t/**\n\t\t\t * The before.ft.breakpoints event is raised if the breakpoint has changed but before the UI is redrawn and is supplied both the current breakpoint\n\t\t\t * and the next \"new\" one that is about to be applied.\n\t\t\t * Calling preventDefault on this event will prevent the next breakpoint from being applied.\n\t\t\t * @event FooTable.Breakpoints#\"before.ft.breakpoints\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {FooTable.Breakpoint} current - The current breakpoint.\n\t\t\t * @param {FooTable.Breakpoint} next - The breakpoint that is about to be applied.\n\t\t\t */\n\t\t\tself.ft.raise('before.ft.breakpoints', [self.current, bp]).then(function(){\n\t\t\t\tvar previous = self.current;\n\t\t\t\tself.current = bp;\n\t\t\t\treturn self.ft.draw().then(function(){\n\t\t\t\t\t/**\n\t\t\t\t\t * The after.ft.breakpoints event is raised after the breakpoint has changed and the UI is redrawn and is supplied both the \"new\" current breakpoint\n\t\t\t\t\t * and the previous one that was replaced.\n\t\t\t\t\t * @event FooTable.Breakpoints#\"after.ft.breakpoints\"\n\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t * @param {FooTable.Breakpoint} current - The current breakpoint.\n\t\t\t\t\t * @param {FooTable.Breakpoint} previous - The breakpoint that was just replaced.\n\t\t\t\t\t */\n\t\t\t\t\tself.ft.raise('after.ft.breakpoints', [self.current, previous]);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Attempts to return a {@link FooTable.Breakpoint} instance when passed a {@link FooTable.Breakpoint},\n\t\t * the {@link FooTable.Breakpoint#name} string or if nothing is supplied the current breakpoint.\n\t\t * @instance\n\t\t * @param {(FooTable.Breakpoint|string|number)} [breakpoint] - The breakpoint to retrieve.\n\t\t * @returns {FooTable.Breakpoint}\n\t\t */\n\t\tget: function(breakpoint){\n\t\t\tif (F.is.undef(breakpoint)) return this.calculate();\n\t\t\tif (breakpoint instanceof F.Breakpoint) return breakpoint;\n\t\t\tif (F.is.string(breakpoint)) return F.arr.first(this.array, function (bp) { return bp.name == breakpoint; });\n\t\t\tif (F.is.number(breakpoint)) return breakpoint >= 0 && breakpoint < this.array.length ? this.array[breakpoint] : null;\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Gets the width used to determine breakpoints whether it be from the viewport, parent or a custom function.\n\t\t * @instance\n\t\t * @returns {number}\n\t\t */\n\t\tgetWidth: function(){\n\t\t\tif (F.is.fn(this.o.getWidth)) return this.o.getWidth(this.ft);\n\t\t\tif (this.useParentWidth == true) return this.getParentWidth();\n\t\t\treturn this.getViewportWidth();\n\t\t},\n\t\t/**\n\t\t * Gets the tables direct parents width.\n\t\t * @instance\n\t\t * @returns {number}\n\t\t */\n\t\tgetParentWidth: function(){\n\t\t\treturn this.ft.$el.parent().width();\n\t\t},\n\t\t/**\n\t\t * Gets the current viewport width.\n\t\t * @instance\n\t\t * @returns {number}\n\t\t */\n\t\tgetViewportWidth: function(){\n\t\t\treturn Math.max(document.documentElement.clientWidth, window.innerWidth, 0);\n\t\t}\n\t});\n\n\tF.components.register('breakpoints', F.Breakpoints, 1000);\n\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * A space delimited string of breakpoint names that specify when the column will be hidden. You can also specify \"all\" to make a column permanently display in an expandable detail row.\n\t * @type {string}\n\t * @default null\n\t * @example <caption>The below shows how this value would be set</caption>\n\t * breakpoints: \"md\"\n\t */\n\tF.Column.prototype.breakpoints = null;\n\n\tF.Column.prototype.__breakpoints_define__ = function(definition){\n\t\tthis.breakpoints = F.is.emptyString(definition.breakpoints) ? null : definition.breakpoints;\n\t};\n\n\tF.Column.extend('define', function(definition){\n\t\tthis._super(definition);\n\t\tthis.__breakpoints_define__(definition);\n\t});\n})(FooTable);\n(function(F){\n\t/**\n\t * An object containing the breakpoints for the plugin.\n\t * @type {object.<string, number>}\n\t * @default { \"xs\": 480, \"sm\": 768, \"md\": 992, \"lg\": 1200 }\n\t */\n\tF.Defaults.prototype.breakpoints = null;\n\n\t/**\n\t * Whether or not breakpoints cascade. When set to true all breakpoints larger than the current will also be hidden along with it.\n\t * @type {boolean}\n\t * @default false\n\t */\n\tF.Defaults.prototype.cascade = false;\n\n\t/**\n\t * Whether or not to calculate breakpoints on the width of the parent element rather than the viewport.\n\t * @type {boolean}\n\t * @default false\n\t */\n\tF.Defaults.prototype.useParentWidth = false;\n\n\t/**\n\t * A function used to override the default getWidth function with a custom one.\n\t * @type {function}\n\t * @default null\n\t * @example <caption>The below shows what the default getWidth function would look like.</caption>\n\t * getWidth: function(instance){\n\t * \tif (instance.o.useParentWidth == true) return instance.$el.parent().width();\n\t * \treturn instance.breakpoints.getViewportWidth();\n\t * }\n\t */\n\tF.Defaults.prototype.getWidth = null;\n})(FooTable);\n(function($, F){\n\tF.Columns = F.Component.extend(/** @lends FooTable.Columns */{\n\t\t/**\n\t\t * The columns class contains all the logic for handling columns.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table -  The parent {@link FooTable.Table} this component belongs to.\n\t\t * @returns {FooTable.Columns}\n\t\t */\n\t\tconstruct: function(table){\n\t\t\t// call the base class constructor\n\t\t\tthis._super(table, true);\n\n\t\t\t/* PROTECTED */\n\t\t\t/**\n\t\t\t * This provides a shortcut to the {@link FooTable.Table#options} object.\n\t\t\t * @protected\n\t\t\t * @type {FooTable.Table#options}\n\t\t\t */\n\t\t\tthis.o = table.o;\n\n\t\t\t/* PUBLIC */\n\t\t\t/**\n\t\t\t * An array of {@link FooTable.Column} objects created from parsing the options and/or DOM.\n\t\t\t * @type {Array.<FooTable.Column>}\n\t\t\t */\n\t\t\tthis.array = [];\n\t\t\t/**\n\t\t\t * The jQuery header row object.\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$header = null;\n\t\t\t/**\n\t\t\t * Whether or not to display the header row.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.showHeader = table.o.showHeader;\n\n\t\t\tthis._fromHTML = F.is.emptyArray(table.o.columns) && !F.is.promise(table.o.columns);\n\t\t},\n\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * This parses the columns from either the tables rows or the supplied options.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The tables jQuery data object.\n\t\t * @returns {jQuery.Promise}\n\t\t * @this FooTable.Columns\n\t\t */\n\t\tparse: function(data){\n\t\t\tvar self = this;\n\t\t\treturn $.Deferred(function(d){\n\t\t\t\tfunction merge(cols1, cols2){\n\t\t\t\t\tvar merged = [];\n\t\t\t\t\t// check if either of the arrays is empty as it can save us having to merge them by index.\n\t\t\t\t\tif (cols1.length == 0 || cols2.length == 0){\n\t\t\t\t\t\tmerged = cols1.concat(cols2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// at this point we have two arrays of column definitions, we now need to merge them based on there index properties\n\t\t\t\t\t\t// first figure out the highest column index provided so we can loop that many times to merge all columns and provide\n\t\t\t\t\t\t// defaults where nothing was specified (fill in the gaps in the array as it were).\n\t\t\t\t\t\tvar highest = 0;\n\t\t\t\t\t\tF.arr.each(cols1.concat(cols2), function(c){\n\t\t\t\t\t\t\tif (c.index > highest) highest = c.index;\n\t\t\t\t\t\t});\n\t\t\t\t\t\thighest++;\n\t\t\t\t\t\tfor (var i = 0, cols1_c, cols2_c; i < highest; i++){\n\t\t\t\t\t\t\tcols1_c = {};\n\t\t\t\t\t\t\tF.arr.each(cols1, function(c){\n\t\t\t\t\t\t\t\tif (c.index == i){\n\t\t\t\t\t\t\t\t\tcols1_c = c;\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcols2_c = {};\n\t\t\t\t\t\t\tF.arr.each(cols2, function(c){\n\t\t\t\t\t\t\t\tif (c.index == i){\n\t\t\t\t\t\t\t\t\tcols2_c = c;\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tmerged.push($.extend(true, {}, cols1_c, cols2_c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn merged;\n\t\t\t\t}\n\n\t\t\t\tvar json = [], html = [];\n\t\t\t\t// get the column options from the content\n\t\t\t\tvar $header = self.ft.$el.find('tr.footable-header, thead > tr:last:has([data-breakpoints]), tbody > tr:first:has([data-breakpoints]), thead > tr:last, tbody > tr:first').first(), $cell, cdata;\n\t\t\t\tif ($header.length > 0){\n\t\t\t\t\tvar virtual = $header.parent().is('tbody') && $header.children().length == $header.children('td').length;\n\t\t\t\t\tif (!virtual) self.$header = $header.addClass('footable-header');\n\t\t\t\t\t$header.children('td,th').each(function(i, cell){\n\t\t\t\t\t\t$cell = $(cell);\n\t\t\t\t\t\tcdata = $cell.data();\n\t\t\t\t\t\tcdata.index = i;\n\t\t\t\t\t\tcdata.$el = $cell;\n\t\t\t\t\t\tcdata.virtual = virtual;\n\t\t\t\t\t\thtml.push(cdata);\n\t\t\t\t\t});\n\t\t\t\t\tif (virtual) self.showHeader = false;\n\t\t\t\t}\n\t\t\t\t// get the supplied column options\n\t\t\t\tif (F.is.array(self.o.columns) && !F.is.emptyArray(self.o.columns)){\n\t\t\t\t\tF.arr.each(self.o.columns, function(c, i){\n\t\t\t\t\t\tc.index = i;\n\t\t\t\t\t\tjson.push(c);\n\t\t\t\t\t});\n\t\t\t\t\tself.parseFinalize(d, merge(json, html));\n\t\t\t\t} else if (F.is.promise(self.o.columns)){\n\t\t\t\t\tself.o.columns.then(function(cols){\n\t\t\t\t\t\tF.arr.each(cols, function(c, i){\n\t\t\t\t\t\t\tc.index = i;\n\t\t\t\t\t\t\tjson.push(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tself.parseFinalize(d, merge(json, html));\n\t\t\t\t\t}, function(xhr){\n\t\t\t\t\t\td.reject(Error('Columns ajax request error: ' + xhr.status + ' (' + xhr.statusText + ')'));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tself.parseFinalize(d, merge(json, html));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Used to finalize the parsing of columns it is supplied the parse deferred object which must be resolved with an array of {@link FooTable.Column} objects\n\t\t * or rejected with an error.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {jQuery.Deferred} deferred - The deferred object used for parsing.\n\t\t * @param {Array.<object>} cols - An array of all merged column definitions.\n\t\t */\n\t\tparseFinalize: function(deferred, cols){\n\t\t\t// we now have a merged array of all column definitions supplied to the plugin, time to make the objects.\n\t\t\tvar self = this, columns = [], column;\n\t\t\tF.arr.each(cols, function(def){\n\t\t\t\t// if we have a column registered using the definition type then create an instance of that column otherwise just create a default text column.\n\t\t\t\tif (column = F.columns.contains(def.type) ? F.columns.make(def.type, self.ft, def) : new F.Column(self.ft, def))\n\t\t\t\t\tcolumns.push(column);\n\t\t\t});\n\t\t\tif (F.is.emptyArray(columns)){\n\t\t\t\tdeferred.reject(Error(\"No columns supplied.\"));\n\t\t\t} else {\n\t\t\t\t// make sure to sort by the column index as the merge process may have mixed them up\n\t\t\t\tcolumns.sort(function(a, b){ return a.index - b.index; });\n\t\t\t\tdeferred.resolve(columns);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * The columns preinit method is used to parse and check the column options supplied from both static content and through the constructor.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the root table element.\n\t\t * @this FooTable.Columns\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.columns event is raised before any UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Columns#\"preinit.ft.columns\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\treturn self.ft.raise('preinit.ft.columns', [data]).then(function(){\n\t\t\t\treturn self.parse(data).then(function(columns){\n\t\t\t\t\tself.array = columns;\n\t\t\t\t\tself.showHeader = F.is.boolean(data.showHeader) ? data.showHeader : self.showHeader;\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the columns creating the table header if required.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Columns#\"init.ft.columns\"\n\t\t * @this FooTable.Columns\n\t\t */\n\t\tinit: function(){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The init.ft.columns event is raised after the header row is created/parsed for column data.\n\t\t\t * @event FooTable.Columns#\"init.ft.columns\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} instance - The instance of the plugin raising the event.\n\t\t\t * @param {Array.<FooTable.Column>} columns - The array of {@link FooTable.Column} objects parsed from the options and/or DOM.\n\t\t\t */\n\t\t\treturn this.ft.raise('init.ft.columns', [ self.array ]).then(function(){\n\t\t\t\tself.$create();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys the columns component removing any UI generated from the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Columns#\"destroy.ft.columns\"\n\t\t */\n\t\tdestroy: function(){\n\t\t\t/**\n\t\t\t * The destroy.ft.columns event is raised before its UI is removed.\n\t\t\t * Calling preventDefault on this event will prevent the component from being destroyed.\n\t\t\t * @event FooTable.Columns#\"destroy.ft.columns\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('destroy.ft.columns').then(function(){\n\t\t\t\tif (!self._fromHTML) self.$header.remove();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * The predraw method called from within the {@link FooTable.Table#draw} method.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Columns\n\t\t */\n\t\tpredraw: function(){\n\t\t\tvar self = this, first = true;\n\t\t\tself.visibleColspan = 0;\n\t\t\tself.firstVisibleIndex = 0;\n\t\t\tself.lastVisibleIndex = 0;\n\t\t\tself.hasHidden = false;\n\t\t\tF.arr.each(self.array, function(col){\n\t\t\t\tcol.hidden = !self.ft.breakpoints.visible(col.breakpoints);\n\t\t\t\tif (!col.hidden && col.visible){\n\t\t\t\t\tif (first){\n\t\t\t\t\t\tself.firstVisibleIndex = col.index;\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t}\n\t\t\t\t\tself.lastVisibleIndex = col.index;\n\t\t\t\t\tself.visibleColspan++;\n\t\t\t\t}\n\t\t\t\tif (col.hidden) self.hasHidden = true;\n\t\t\t});\n\t\t\tself.ft.$el.toggleClass('breakpoint', self.hasHidden);\n\t\t},\n\t\t/**\n\t\t * Performs the actual drawing of the columns, hiding or displaying them depending on there breakpoints.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Columns\n\t\t */\n\t\tdraw: function(){\n\t\t\tF.arr.each(this.array, function(col){\n\t\t\t\tcol.$el.css('display', (col.hidden || !col.visible  ? 'none' : 'table-cell'));\n\t\t\t});\n\t\t\tif (!this.showHeader && F.is.jq(this.$header.parent())){\n\t\t\t\tthis.$header.detach();\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Creates the header row for the table from the parsed column definitions.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Columns\n\t\t */\n\t\t$create: function(){\n\t\t\tvar self = this;\n\t\t\tself.$header = F.is.jq(self.$header) ? self.$header : $('<tr/>', {'class': 'footable-header'});\n\t\t\tself.$header.children('th,td').detach();\n\t\t\tF.arr.each(self.array, function(col){\n\t\t\t\tself.$header.append(col.$el);\n\t\t\t});\n\t\t\tif (self.showHeader && !F.is.jq(self.$header.parent())){\n\t\t\t\tself.ft.$el.children('thead').append(self.$header);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Attempts to return a {@link FooTable.Column} instance when passed the {@link FooTable.Column} instance, the {@link FooTable.Column#name} string or the {@link FooTable.Column#index} number.\n\t\t * If supplied a function this will return an array by iterating all columns passing the index and column itself to the supplied callback as arguments.\n\t\t * Returning true in the callback will include the column in the result.\n\t\t * @instance\n\t\t * @param {(FooTable.Column|string|number|function)} column - The column to retrieve.\n\t\t * @returns {(Array.<FooTable.Column>|FooTable.Column|null)} The column if one is found otherwise it returns NULL.\n\t\t * @example <caption>This example shows retrieving a column by name assuming a column called \"id\" exists. The <code>columns</code> object is an instance of {@link FooTable.Columns}.</caption>\n\t\t * var column = columns.get('id');\n\t\t * if (column instanceof FooTable.Column){\n\t\t * \t// found the \"id\" column\n\t\t * } else {\n\t\t * \t// no column with a name of \"id\" exists\n\t\t * }\n\t\t * // to get an array of all hidden columns\n\t\t * var columns = columns.get(function(col){\n\t\t *  return col.hidden;\n\t\t * });\n\t\t */\n\t\tget: function(column){\n\t\t\tif (column instanceof F.Column) return column;\n\t\t\tif (F.is.string(column)) return F.arr.first(this.array, function (col) { return col.name == column; });\n\t\t\tif (F.is.number(column)) return F.arr.first(this.array, function (col) { return col.index == column; });\n\t\t\tif (F.is.fn(column)) return F.arr.get(this.array, column);\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Takes an array of column names, index's or actual {@link FooTable.Column} and ensures that an array of only {@link FooTable.Column} is returned.\n\t\t * @instance\n\t\t * @param {(Array.<string>|Array.<number>|Array.<FooTable.Column>)} columns - The array of column names, index's or {@link FooTable.Column} to check.\n\t\t * @returns {Array.<FooTable.Column>}\n\t\t */\n\t\tensure: function(columns){\n\t\t\tvar self = this, result = [];\n\t\t\tif (!F.is.array(columns)) return result;\n\t\t\tF.arr.each(columns, function(name){\n\t\t\t\tresult.push(self.get(name));\n\t\t\t});\n\t\t\treturn result;\n\t\t}\n\t});\n\n\tF.components.register('columns', F.Columns, 900);\n\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * An array containing the column options or a jQuery promise that resolves returning the columns. The index of the definitions must match the index of each column as it should appear in the table. For more information on the options available see the {@link FooTable.Column} object.\n\t * @type {(Array.<object>|jQuery.Promise)}\n\t * @default []\n\t * @example <caption>The below shows column definitions for a row defined as <code>{ id: Number, name: String, age: Number }</code>. The ID column has a fixed width, the table is initially sorted on the Name column and the Age column will be hidden on phones.</caption>\n\t * columns: [\n\t * \t{ name: 'id', title: 'ID', type: 'number' },\n\t *\t{ name: 'name', title: 'Name', sorted: true, direction: 'ASC' }\n\t *\t{ name: 'age', title: 'Age', type: 'number', breakpoints: 'xs' }\n\t * ]\n\t */\n\tF.Defaults.prototype.columns = [];\n\n\t/**\n\t * Specifies whether or not the column headers should be displayed.\n\t * @type {boolean}\n\t * @default true\n\t */\n\tF.Defaults.prototype.showHeader = true;\n})(FooTable);\n(function ($, F) {\n\tF.Rows = F.Component.extend(/** @lends FooTable.Rows */{\n\t\t/**\n\t\t * The rows class contains all the logic for handling rows.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table -  The parent {@link FooTable.Table} this component belongs to.\n\t\t * @returns {FooTable.Rows}\n\t\t */\n\t\tconstruct: function (table) {\n\t\t\t// call the base class constructor\n\t\t\tthis._super(table, true);\n\n\t\t\t/**\n\t\t\t * This provides a shortcut to the {@link FooTable.Table#options} object.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {FooTable.Table#options}\n\t\t\t */\n\t\t\tthis.o = table.o;\n\t\t\t/**\n\t\t\t * The current working array of {@link FooTable.Row} objects.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {Array.<FooTable.Row>}\n\t\t\t * @default []\n\t\t\t */\n\t\t\tthis.array = [];\n\t\t\t/**\n\t\t\t * The base array of rows parsed from either the DOM or the constructor options.\n\t\t\t * The {@link FooTable.Rows#current} member is populated with a shallow clone of this array\n\t\t\t * during the predraw operation before any core or custom components are executed.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {Array.<FooTable.Row>}\n\t\t\t * @default []\n\t\t\t */\n\t\t\tthis.all = [];\n\t\t\t/**\n\t\t\t * Whether or not to display a toggle in each row when it contains hidden columns.\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.showToggle = table.o.showToggle;\n\t\t\t/**\n\t\t\t * The CSS selector used to filter row click events. If the event.target property matches the selector the row will be toggled.\n\t\t\t * @type {string}\n\t\t\t * @default \"tr,td,.footable-toggle\"\n\t\t\t */\n\t\t\tthis.toggleSelector = table.o.toggleSelector;\n\t\t\t/**\n\t\t\t * Specifies which column the row toggle is appended to. Supports only two values; \"first\" and \"last\"\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.toggleColumn = table.o.toggleColumn;\n\t\t\t/**\n\t\t\t * The text to display when the table has no rows.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.emptyString = table.o.empty;\n\t\t\t/**\n\t\t\t * Whether or not the first rows details are expanded by default when displayed on a device that hides any columns.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.expandFirst = table.o.expandFirst;\n\t\t\t/**\n\t\t\t * Whether or not all row details are expanded by default when displayed on a device that hides any columns.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.expandAll = table.o.expandAll;\n\t\t\t/**\n\t\t\t * The jQuery object that contains the empty row control.\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$empty = null;\n\t\t\tthis._fromHTML = F.is.emptyArray(table.o.rows) && !F.is.promise(table.o.rows);\n\t\t},\n\t\t/**\n\t\t * This parses the rows from either the tables rows or the supplied options.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {jQuery.Promise}\n\t\t */\n\t\tparse: function(){\n\t\t\tvar self = this;\n\t\t\treturn $.Deferred(function(d){\n\t\t\t\tvar $rows = self.ft.$el.children('tbody').children('tr');\n\t\t\t\tif (F.is.array(self.o.rows) && self.o.rows.length > 0){\n\t\t\t\t\tself.parseFinalize(d, self.o.rows);\n\t\t\t\t} else if (F.is.promise(self.o.rows)){\n\t\t\t\t\tself.o.rows.then(function(rows){\n\t\t\t\t\t\tself.parseFinalize(d, rows);\n\t\t\t\t\t}, function(xhr){\n\t\t\t\t\t\td.reject(Error('Rows ajax request error: ' + xhr.status + ' (' + xhr.statusText + ')'));\n\t\t\t\t\t});\n\t\t\t\t} else if (F.is.jq($rows)){\n\t\t\t\t\tself.parseFinalize(d, $rows);\n\t\t\t\t\t$rows.detach();\n\t\t\t\t} else {\n\t\t\t\t\tself.parseFinalize(d, []);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Used to finalize the parsing of rows it is supplied the parse deferred object which must be resolved with an array of {@link FooTable.Row} objects\n\t\t * or rejected with an error.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {jQuery.Deferred} deferred - The deferred object used for parsing.\n\t\t * @param {(Array.<object>|jQuery)} rows - An array of row values and options or the jQuery object containing all rows.\n\t\t */\n\t\tparseFinalize: function(deferred, rows){\n\t\t\tvar self = this, result = $.map(rows, function(r){\n\t\t\t\treturn new F.Row(self.ft, self.ft.columns.array, r);\n\t\t\t});\n\t\t\tdeferred.resolve(result);\n\t\t},\n\t\t/**\n\t\t * The columns preinit method is used to parse and check the column options supplied from both static content and through the constructor.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the root table element.\n\t\t * @fires FooTable.Rows#\"preinit.ft.rows\"\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.rows event is raised before any UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Rows#\"preinit.ft.rows\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\treturn self.ft.raise('preinit.ft.rows', [data]).then(function(){\n\t\t\t\treturn self.parse().then(function(rows){\n\t\t\t\t\tself.all = rows;\n\t\t\t\t\tself.array = self.all.slice(0);\n\t\t\t\t\tself.showToggle = F.is.boolean(data.showToggle) ? data.showToggle : self.showToggle;\n\t\t\t\t\tself.toggleSelector = F.is.string(data.toggleSelector) ? data.toggleSelector : self.toggleSelector;\n\t\t\t\t\tself.toggleColumn = F.is.string(data.toggleColumn) ? data.toggleColumn : self.toggleColumn;\n\t\t\t\t\tif (self.toggleColumn != \"first\" && self.toggleColumn != \"last\") self.toggleColumn = \"first\";\n\t\t\t\t\tself.emptyString = F.is.string(data.empty) ? data.empty : self.emptyString;\n\t\t\t\t\tself.expandFirst = F.is.boolean(data.expandFirst) ? data.expandFirst : self.expandFirst;\n\t\t\t\t\tself.expandAll = F.is.boolean(data.expandAll) ? data.expandAll : self.expandAll;\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the rows class using the supplied table and options.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Rows#\"init.ft.rows\"\n\t\t */\n\t\tinit: function () {\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The init.ft.rows event is raised after the the rows are parsed from either the DOM or the options.\n\t\t\t * Calling preventDefault on this event will disable the entire plugin.\n\t\t\t * @event FooTable.Rows#\"init.ft.rows\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} instance - The instance of the plugin raising the event.\n\t\t\t * @param {Array.<FooTable.Row>} rows - The array of {@link FooTable.Row} objects parsed from the DOM or the options.\n\t\t\t */\n\t\t\treturn self.ft.raise('init.ft.rows', [self.all]).then(function(){\n\t\t\t\tself.$create();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys the rows component removing any UI generated from the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Rows#\"destroy.ft.rows\"\n\t\t */\n\t\tdestroy: function(){\n\t\t\t/**\n\t\t\t * The destroy.ft.rows event is raised before its UI is removed.\n\t\t\t * Calling preventDefault on this event will prevent the component from being destroyed.\n\t\t\t * @event FooTable.Rows#\"destroy.ft.rows\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('destroy.ft.rows').then(function(){\n\t\t\t\tF.arr.each(self.array, function(row){\n\t\t\t\t\trow.predraw(!self._fromHTML);\n\t\t\t\t});\n\t\t\t\tself.all = self.array = [];\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Performs the predraw operations that are required including creating the shallow clone of the {@link FooTable.Rows#array} to work with.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tpredraw: function(){\n\t\t\tF.arr.each(this.array, function(row){\n\t\t\t\trow.predraw();\n\t\t\t});\n\t\t\tthis.array = this.all.slice(0);\n\t\t},\n\t\t$create: function(){\n\t\t\tthis.$empty = $('<tr/>', { 'class': 'footable-empty' }).append($('<td/>').text(this.emptyString));\n\t\t},\n\t\t/**\n\t\t * Performs the actual drawing of the table rows.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tdraw: function(){\n\t\t\tvar self = this, $tbody = self.ft.$el.children('tbody'), first = true;\n\t\t\t// if we have rows\n\t\t\tif (self.array.length > 0){\n\t\t\t\tself.$empty.detach();\n\t\t\t\t// loop through them appending to the tbody and then drawing\n\t\t\t\tF.arr.each(self.array, function(row){\n\t\t\t\t\tif ((self.expandFirst && first) || self.expandAll){\n\t\t\t\t\t\trow.expanded = true;\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t}\n\t\t\t\t\trow.draw($tbody);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// otherwise display the $empty row\n\t\t\t\tself.$empty.children('td').attr('colspan', self.ft.columns.visibleColspan);\n\t\t\t\t$tbody.append(self.$empty);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Loads a JSON array of row objects into the table\n\t\t * @instance\n\t\t * @param {Array.<object>} data - An array of row objects to load.\n\t\t * @param {boolean} [append=false] - Whether or not to append the new rows to the current rows array or to replace them entirely.\n\t\t */\n\t\tload: function(data, append){\n\t\t\tvar self = this, rows = $.map(data, function(r){\n\t\t\t\treturn new F.Row(self.ft, self.ft.columns.array, r);\n\t\t\t});\n\t\t\tF.arr.each(this.array, function(row){\n\t\t\t\trow.predraw();\n\t\t\t});\n\t\t\tthis.all = (F.is.boolean(append) ? append : false) ? this.all.concat(rows) : rows;\n\t\t\tthis.array = this.all.slice(0);\n\t\t\tthis.ft.draw();\n\t\t},\n\t\t/**\n\t\t * Expands all visible rows.\n\t\t * @instance\n\t\t */\n\t\texpand: function(){\n\t\t\tF.arr.each(this.array, function(row){\n\t\t\t\trow.expand();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Collapses all visible rows.\n\t\t * @instance\n\t\t */\n\t\tcollapse: function(){\n\t\t\tF.arr.each(this.array, function(row){\n\t\t\t\trow.collapse();\n\t\t\t});\n\t\t}\n\t});\n\n\tF.components.register('rows', F.Rows, 800);\n\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * An array of JSON objects containing the row data or a jQuery promise that resolves returning the row data.\n\t * @type {(Array.<object>|jQuery.Promise)}\n\t * @default []\n\t */\n\tF.Defaults.prototype.rows = [];\n\n\t/**\n\t * A string to display when there are no rows in the table.\n\t * @type {string}\n\t * @default \"No results\"\n\t */\n\tF.Defaults.prototype.empty = 'No results';\n\n\t/**\n\t * Whether or not the toggle is appended to each row.\n\t * @type {boolean}\n\t * @default true\n\t */\n\tF.Defaults.prototype.showToggle = true;\n\n\t/**\n\t * The CSS selector used to filter row click events. If the event.target property matches the selector the row will be toggled.\n\t * @type {string}\n\t * @default \"tr,td,.footable-toggle\"\n\t */\n\tF.Defaults.prototype.toggleSelector = 'tr,td,.footable-toggle';\n\n\t/**\n\t * Specifies which column to display the row toggle in. The only supported values are \"first\" or \"last\".\n\t * @type {string}\n\t * @default \"first\"\n\t */\n\tF.Defaults.prototype.toggleColumn = 'first';\n\n\t/**\n\t * Whether or not the first rows details are expanded by default when displayed on a device that hides any columns.\n\t * @type {boolean}\n\t */\n\tF.Defaults.prototype.expandFirst = false;\n\n\t/**\n\t * Whether or not all row details are expanded by default when displayed on a device that hides any columns.\n\t * @type {boolean}\n\t */\n\tF.Defaults.prototype.expandAll = false;\n})(FooTable);\n(function(F){\n\t/**\n\t * Loads a JSON array of row objects into the table\n\t * @param {Array.<object>} data - An array of row objects to load.\n\t * @param {boolean} [append=false] - Whether or not to append the new rows to the current rows array or to replace them entirely.\n\t */\n\tF.Table.prototype.loadRows = function(data, append){\n\t\tthis.rows.load(data, append);\n\t};\n})(FooTable);\n(function(F){\n\tF.Filter = F.Class.extend(/** @lends FooTable.Filter */{\n\t\t/**\n\t\t * The filter object contains the query to filter by and the columns to apply it to.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {string} name - The name for the filter.\n\t\t * @param {(string|FooTable.Query)} query - The query for the filter.\n\t\t * @param {Array.<FooTable.Column>} columns - The columns to apply the query to.\n\t\t * @param {string} [space=\"AND\"] - How the query treats space chars.\n\t\t * @param {boolean} [connectors=true] - Whether or not to replace phrase connectors (+.-_) with spaces.\n\t\t * @param {boolean} [ignoreCase=true] - Whether or not ignore case when matching.\n\t\t * @param {boolean} [hidden=true] - Whether or not this is a hidden filter.\n\t\t * @returns {FooTable.Filter}\n\t\t */\n\t\tconstruct: function(name, query, columns, space, connectors, ignoreCase, hidden){\n\t\t\t/**\n\t\t\t * The name of the filter.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.name = name;\n\t\t\t/**\n\t\t\t * A string specifying how the filter treats space characters. Can be either \"OR\" or \"AND\".\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.space = F.is.string(space) && (space == 'OR' || space == 'AND') ? space : 'AND';\n\t\t\t/**\n\t\t\t * Whether or not to replace phrase connectors (+.-_) with spaces before executing the query.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.connectors = F.is.boolean(connectors) ? connectors : true;\n\t\t\t/**\n\t\t\t * Whether or not ignore case when matching.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.ignoreCase = F.is.boolean(ignoreCase) ? ignoreCase : true;\n\t\t\t/**\n\t\t\t * Whether or not this is a hidden filter.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.hidden = F.is.boolean(hidden) ? hidden : false;\n\t\t\t/**\n\t\t\t * The query for the filter.\n\t\t\t * @instance\n\t\t\t * @type {(string|FooTable.Query)}\n\t\t\t */\n\t\t\tthis.query = query instanceof F.Query ? query : new F.Query(query, this.space, this.connectors, this.ignoreCase);\n\t\t\t/**\n\t\t\t * The columns to apply the query to.\n\t\t\t * @instance\n\t\t\t * @type {Array.<FooTable.Column>}\n\t\t\t */\n\t\t\tthis.columns = columns;\n\t\t},\n\t\t/**\n\t\t * Checks if the current filter matches the supplied string.\n\t\t * If the current query property is a string it will be auto converted to a {@link FooTable.Query} object to perform the match.\n\t\t * @instance\n\t\t * @param {string} str - The string to check.\n\t\t * @returns {boolean}\n\t\t */\n\t\tmatch: function(str){\n\t\t\tif (!F.is.string(str)) return false;\n\t\t\tif (F.is.string(this.query)){\n\t\t\t\tthis.query = new F.Query(this.query, this.space, this.connectors, this.ignoreCase);\n\t\t\t}\n\t\t\treturn this.query instanceof F.Query ? this.query.match(str) : false;\n\t\t},\n\t\t/**\n\t\t * Checks if the current filter matches the supplied {@link FooTable.Row}.\n\t\t * @instance\n\t\t * @param {FooTable.Row} row - The row to check.\n\t\t * @returns {boolean}\n\t\t */\n\t\tmatchRow: function(row){\n\t\t\tvar self = this, text = F.arr.map(row.cells, function(cell){\n\t\t\t\treturn F.arr.contains(self.columns, cell.column) ? cell.filterValue : null;\n\t\t\t}).join(' ');\n\t\t\treturn self.match(text);\n\t\t}\n\t});\n\n})(FooTable);\n(function ($, F) {\n\tF.Filtering = F.Component.extend(/** @lends FooTable.Filtering */{\n\t\t/**\n\t\t * The filtering component adds a search input and column selector dropdown to the table allowing users to filter the using space delimited queries.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table - The parent {@link FooTable.Table} object for the component.\n\t\t * @returns {FooTable.Filtering}\n\t\t */\n\t\tconstruct: function (table) {\n\t\t\t// call the constructor of the base class\n\t\t\tthis._super(table, table.o.filtering.enabled);\n\n\t\t\t/* PUBLIC */\n\t\t\t/**\n\t\t\t * The filters to apply to the current {@link FooTable.Rows#array}.\n\t\t\t * @instance\n\t\t\t * @type {Array.<FooTable.Filter>}\n\t\t\t */\n\t\t\tthis.filters = table.o.filtering.filters;\n\t\t\t/**\n\t\t\t * The delay in milliseconds before the query is auto applied after a change.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.delay = table.o.filtering.delay;\n\t\t\t/**\n\t\t\t * The minimum number of characters allowed in the search input before it is auto applied.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.min = table.o.filtering.min;\n\t\t\t/**\n\t\t\t * Specifies how whitespace in a filter query is handled.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.space = table.o.filtering.space;\n\t\t\t/**\n\t\t\t * Whether or not to replace phrase connectors (+.-_) with spaces before executing the query.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.connectors = table.o.filtering.connectors;\n\t\t\t/**\n\t\t\t * Whether or not ignore case when matching.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.ignoreCase = table.o.filtering.ignoreCase;\n\t\t\t/**\n\t\t\t * Whether or not search queries are treated as phrases when matching.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.exactMatch = table.o.filtering.exactMatch;\n\t\t\t/**\n\t\t\t * The placeholder text to display within the search $input.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.placeholder = table.o.filtering.placeholder;\n\t\t\t/**\n\t\t\t * The title to display at the top of the search input column select.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.dropdownTitle = table.o.filtering.dropdownTitle;\n\t\t\t/**\n\t\t\t * The position of the $search input within the filtering rows cell.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.position = table.o.filtering.position;\n\t\t\t/**\n\t\t\t * Whether or not to focus the search input after the search/clear button is clicked or after auto applying the search input query.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.focus = table.o.filtering.focus;\n\t\t\t/**\n\t\t\t * A selector specifying where to place the filtering components form, if null the form is displayed within a row in the head of the table.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.container = table.o.filtering.container;\n\t\t\t/**\n\t\t\t * The jQuery object of the element containing the entire filtering form.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$container = null;\n\t\t\t/**\n\t\t\t * The jQuery row object that contains all the filtering specific elements.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$row = null;\n\t\t\t/**\n\t\t\t * The jQuery cell object that contains the search input and column selector.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$cell = null;\n\t\t\t/**\n\t\t\t * The jQuery form object of the form that contains the search input and column selector.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$form = null;\n\t\t\t/**\n\t\t\t * The jQuery object of the column selector dropdown.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$dropdown = null;\n\t\t\t/**\n\t\t\t * The jQuery object of the search input.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$input = null;\n\t\t\t/**\n\t\t\t * The jQuery object of the search button.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$button = null;\n\n\t\t\t/* PRIVATE */\n\t\t\t/**\n\t\t\t * The timeout ID for the filter changed event.\n\t\t\t * @instance\n\t\t\t * @private\n\t\t\t * @type {?number}\n\t\t\t */\n\t\t\tthis._filterTimeout = null;\n\t\t\t/**\n\t\t\t * The regular expression used to check for encapsulating quotations.\n\t\t\t * @instance\n\t\t\t * @private\n\t\t\t * @type {RegExp}\n\t\t\t */\n\t\t\tthis._exactRegExp = /^\"(.*?)\"$/;\n\t\t},\n\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * Checks the supplied data and options for the filtering component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the parent table.\n\t\t * @fires FooTable.Filtering#\"preinit.ft.filtering\"\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.filtering event is raised before the UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Filtering#\"preinit.ft.filtering\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\treturn self.ft.raise('preinit.ft.filtering').then(function(){\n\t\t\t\t// first check if filtering is enabled via the class being applied\n\t\t\t\tif (self.ft.$el.hasClass('footable-filtering'))\n\t\t\t\t\tself.enabled = true;\n\t\t\t\t// then check if the data-filtering-enabled attribute has been set\n\t\t\t\tself.enabled = F.is.boolean(data.filtering)\n\t\t\t\t\t? data.filtering\n\t\t\t\t\t: self.enabled;\n\n\t\t\t\t// if filtering is not enabled exit early as we don't need to do anything else\n\t\t\t\tif (!self.enabled) return;\n\n\t\t\t\tself.space = F.is.string(data.filterSpace)\n\t\t\t\t\t? data.filterSpace\n\t\t\t\t\t: self.space;\n\n\t\t\t\tself.min = F.is.number(data.filterMin)\n\t\t\t\t\t? data.filterMin\n\t\t\t\t\t: self.min;\n\n\t\t\t\tself.connectors = F.is.boolean(data.filterConnectors)\n\t\t\t\t\t? data.filterConnectors\n\t\t\t\t\t: self.connectors;\n\n\t\t\t\tself.ignoreCase = F.is.boolean(data.filterIgnoreCase)\n\t\t\t\t\t? data.filterIgnoreCase\n\t\t\t\t\t: self.ignoreCase;\n\n\t\t\t\tself.exactMatch = F.is.boolean(data.filterExactMatch)\n\t\t\t\t\t? data.filterExactMatch\n\t\t\t\t\t: self.exactMatch;\n\n\t\t\t\tself.focus = F.is.boolean(data.filterFocus)\n\t\t\t\t\t? data.filterFocus\n\t\t\t\t\t: self.focus;\n\n\t\t\t\tself.delay = F.is.number(data.filterDelay)\n\t\t\t\t\t? data.filterDelay\n\t\t\t\t\t: self.delay;\n\n\t\t\t\tself.placeholder = F.is.string(data.filterPlaceholder)\n\t\t\t\t\t? data.filterPlaceholder\n\t\t\t\t\t: self.placeholder;\n\n\t\t\t\tself.dropdownTitle = F.is.string(data.filterDropdownTitle)\n\t\t\t\t\t? data.filterDropdownTitle\n\t\t\t\t\t: self.dropdownTitle;\n\n\t\t\t\tself.container = F.is.string(data.filterContainer)\n\t\t\t\t\t? data.filterContainer\n\t\t\t\t\t: self.container;\n\n\t\t\t\tself.filters = F.is.array(data.filterFilters)\n\t\t\t\t\t? self.ensure(data.filterFilters)\n\t\t\t\t\t: self.ensure(self.filters);\n\n\t\t\t\tif (self.ft.$el.hasClass('footable-filtering-left'))\n\t\t\t\t\tself.position = 'left';\n\t\t\t\tif (self.ft.$el.hasClass('footable-filtering-center'))\n\t\t\t\t\tself.position = 'center';\n\t\t\t\tif (self.ft.$el.hasClass('footable-filtering-right'))\n\t\t\t\t\tself.position = 'right';\n\n\t\t\t\tself.position = F.is.string(data.filterPosition)\n\t\t\t\t\t? data.filterPosition\n\t\t\t\t\t: self.position;\n\t\t\t},function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the filtering component for the plugin.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Filtering#\"init.ft.filtering\"\n\t\t */\n\t\tinit: function () {\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The init.ft.filtering event is raised before its UI is generated.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Filtering#\"init.ft.filtering\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\treturn self.ft.raise('init.ft.filtering').then(function(){\n\t\t\t\tself.$create();\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys the filtering component removing any UI from the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Filtering#\"destroy.ft.filtering\"\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The destroy.ft.filtering event is raised before its UI is removed.\n\t\t\t * Calling preventDefault on this event will prevent the component from being destroyed.\n\t\t\t * @event FooTable.Filtering#\"destroy.ft.filtering\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\treturn self.ft.raise('destroy.ft.filtering').then(function(){\n\t\t\t\tself.ft.$el.removeClass('footable-filtering')\n\t\t\t\t\t.find('thead > tr.footable-filtering').remove();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Creates the filtering UI from the current options setting the various jQuery properties of this component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Filtering\n\t\t */\n\t\t$create: function () {\n\t\t\tvar self = this;\n\t\t\t// generate the cell that actually contains all the UI.\n\t\t\tvar $form_grp = $('<div/>', {'class': 'form-group footable-filtering-search'})\n\t\t\t\t\t.append($('<label/>', {'class': 'sr-only', text: 'Search'})),\n\t\t\t\t$input_grp = $('<div/>', {'class': 'input-group'}).appendTo($form_grp),\n\t\t\t\t$input_grp_btn = $('<div/>', {'class': 'input-group-btn'}),\n\t\t\t\t$dropdown_toggle = $('<button/>', {type: 'button', 'class': 'btn btn-default'})\n\t\t\t\t\t.on('click', { self: self }, self._onDropdownToggleClicked)\n\t\t\t\t\t.append($('<span/>', {'class': 'caret'})),\n\t\t\t\tposition;\n\n\t\t\tswitch (self.position){\n\t\t\t\tcase 'left': position = 'footable-filtering-left'; break;\n\t\t\t\tcase 'center': position = 'footable-filtering-center'; break;\n\t\t\t\tdefault: position = 'footable-filtering-right'; break;\n\t\t\t}\n\t\t\tself.ft.$el.addClass('footable-filtering').addClass(position);\n\n\t\t\tself.$container = self.container === null ? $() : $(self.container).first();\n\t\t\tif (!self.$container.length){\n\t\t\t\t// add it to a row and then populate it with the search input and column selector dropdown.\n\t\t\t\tself.$row = $('<tr/>', {'class': 'footable-filtering'}).prependTo(self.ft.$el.children('thead'));\n\t\t\t\tself.$cell = $('<th/>').attr('colspan', self.ft.columns.visibleColspan).appendTo(self.$row);\n\t\t\t\tself.$container = self.$cell;\n\t\t\t} else {\n\t\t\t\tself.$container.addClass('footable-filtering-external').addClass(position);\n\t\t\t}\n\t\t\tself.$form = $('<form/>', {'class': 'form-inline'}).append($form_grp).appendTo(self.$container);\n\n\t\t\tself.$input = $('<input/>', {type: 'text', 'class': 'form-control', placeholder: self.placeholder});\n\n\t\t\tself.$button = $('<button/>', {type: 'button', 'class': 'btn btn-primary'})\n\t\t\t\t.on('click', { self: self }, self._onSearchButtonClicked)\n\t\t\t\t.append($('<i/>', {'class': 'icon ion-md-search'}));\n\n\t\t\tself.$dropdown = $('<ul/>', {'class': 'dropdown-menu dropdown-menu-right'});\n\t\t\tif (!F.is.emptyString(self.dropdownTitle)){\n\t\t\t\tself.$dropdown.append($('<li/>', {'class': 'dropdown-header','text': self.dropdownTitle}));\n\t\t\t}\n\t\t\tself.$dropdown.append(\n\t\t\t\tF.arr.map(self.ft.columns.array, function (col) {\n\t\t\t\t\treturn col.filterable ? $('<li/>').append(\n\t\t\t\t\t\t$('<a/>', {'class': 'checkbox'}).append(\n\t\t\t\t\t\t\t$('<label/>', {html: col.title}).prepend(\n\t\t\t\t\t\t\t\t$('<input/>', {type: 'checkbox', checked: true}).data('__FooTableColumn__', col)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t) : null;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tif (self.delay > 0){\n\t\t\t\tself.$input.on('keypress keyup paste', { self: self }, self._onSearchInputChanged);\n\t\t\t\tself.$dropdown.on('click', 'input[type=\"checkbox\"]', {self: self}, self._onSearchColumnClicked);\n\t\t\t}\n\n\t\t\t$input_grp_btn.append(self.$button, $dropdown_toggle, self.$dropdown);\n\t\t\t$input_grp.append(self.$input, $input_grp_btn);\n\t\t},\n\t\t/**\n\t\t * Performs the filtering of rows before they are appended to the page.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tpredraw: function(){\n\t\t\tif (F.is.emptyArray(this.filters))\n\t\t\t\treturn;\n\n\t\t\tvar self = this;\n\t\t\tself.ft.rows.array = $.grep(self.ft.rows.array, function(r){\n\t\t\t\treturn r.filtered(self.filters);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * As the rows are drawn by the {@link FooTable.Rows#draw} method this simply updates the colspan for the UI.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tdraw: function(){\n\t\t\tif (F.is.jq(this.$cell)){\n\t\t\t\tthis.$cell.attr('colspan', this.ft.columns.visibleColspan);\n\t\t\t}\n\t\t\tvar search = this.find('search');\n\t\t\tif (search instanceof F.Filter){\n\t\t\t\tvar query = search.query.val();\n\t\t\t\tif (this.exactMatch && this._exactRegExp.test(query)){\n\t\t\t\t\tquery = query.replace(this._exactRegExp, '$1');\n\t\t\t\t}\n\t\t\t\tthis.$input.val(query);\n\t\t\t} else {\n\t\t\t\tthis.$input.val(null);\n\t\t\t}\n\t\t\tthis.setButton(!F.arr.any(this.filters, function(f){ return !f.hidden; }));\n\t\t},\n\n\t\t/* PUBLIC */\n\t\t/**\n\t\t * Adds or updates the filter using the supplied name, query and columns.\n\t\t * @instance\n\t\t * @param {(string|FooTable.Filter|object)} nameOrFilter - The name for the filter or the actual filter object itself.\n\t\t * @param {(string|FooTable.Query)} [query] - The query for the filter. This is only optional when the first parameter is a filter object.\n\t\t * @param {(Array.<number>|Array.<string>|Array.<FooTable.Column>)} [columns] - The columns to apply the filter to.\n\t\t * \tIf not supplied the filter will be applied to all selected columns in the search input dropdown.\n\t\t * @param {boolean} [ignoreCase=true] - Whether or not ignore case when matching.\n\t\t * @param {boolean} [connectors=true] - Whether or not to replace phrase connectors (+.-_) with spaces.\n\t\t * @param {string} [space=\"AND\"] - How the query treats space chars.\n\t\t * @param {boolean} [hidden=true] - Whether or not this is a hidden filter.\n\t\t */\n\t\taddFilter: function(nameOrFilter, query, columns, ignoreCase, connectors, space, hidden){\n\t\t\tvar f = this.createFilter(nameOrFilter, query, columns, ignoreCase, connectors, space, hidden);\n\t\t\tif (f instanceof F.Filter){\n\t\t\t\tthis.removeFilter(f.name);\n\t\t\t\tthis.filters.push(f);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Removes the filter using the supplied name if it exists.\n\t\t * @instance\n\t\t * @param {string} name - The name of the filter to remove.\n\t\t */\n\t\tremoveFilter: function(name){\n\t\t\tF.arr.remove(this.filters, function(f){ return f.name == name; });\n\t\t},\n\t\t/**\n\t\t * Performs the required steps to handle filtering including the raising of the {@link FooTable.Filtering#\"before.ft.filtering\"} and {@link FooTable.Filtering#\"after.ft.filtering\"} events.\n\t\t * @instance\n\t\t * @param {boolean} [focus=false] - Whether or not to set the focus to the input once filtering is complete.\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Filtering#\"before.ft.filtering\"\n\t\t * @fires FooTable.Filtering#\"after.ft.filtering\"\n\t\t */\n\t\tfilter: function(focus){\n\t\t\tvar self = this;\n\t\t\tself.filters = self.ensure(self.filters);\n\t\t\t/**\n\t\t\t * The before.ft.filtering event is raised before a filter is applied and allows listeners to modify the filter or cancel it completely by calling preventDefault on the jQuery.Event object.\n\t\t\t * @event FooTable.Filtering#\"before.ft.filtering\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {Array.<FooTable.Filter>} filters - The filters that are about to be applied.\n\t\t\t */\n\t\t\treturn self.ft.raise('before.ft.filtering', [self.filters]).then(function(){\n\t\t\t\tself.filters = self.ensure(self.filters);\n\t\t\t\tif (focus){\n\t\t\t\t\tvar start = self.$input.prop('selectionStart'),\n\t\t\t\t\t\tend = self.$input.prop('selectionEnd');\n\t\t\t\t}\n\t\t\t\treturn self.ft.draw().then(function(){\n\t\t\t\t\tif (focus){\n\t\t\t\t\t\tself.$input.focus().prop({\n\t\t\t\t\t\t\tselectionStart: start,\n\t\t\t\t\t\t\tselectionEnd: end\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * The after.ft.filtering event is raised after a filter has been applied.\n\t\t\t\t\t * @event FooTable.Filtering#\"after.ft.filtering\"\n\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t * @param {FooTable.Filter} filter - The filters that were applied.\n\t\t\t\t\t */\n\t\t\t\t\tself.ft.raise('after.ft.filtering', [self.filters]);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Removes the current search filter.\n\t\t * @instance\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Filtering#\"before.ft.filtering\"\n\t\t * @fires FooTable.Filtering#\"after.ft.filtering\"\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.filters = F.arr.get(this.filters, function(f){ return f.hidden; });\n\t\t\treturn this.filter(this.focus);\n\t\t},\n\t\t/**\n\t\t * Toggles the button icon between the search and clear icons based on the supplied value.\n\t\t * @instance\n\t\t * @param {boolean} search - Whether or not to display the search icon.\n\t\t */\n\t\tsetButton: function(search){\n\t\t\tif (!search){\n\t\t\t\tthis.$button.children('.fooicon').removeClass('ion-md-search').addClass('ion-md-close');\n\t\t\t} else {\n\t\t\t\tthis.$button.children('.fooicon').removeClass('ion-md-close').addClass('ion-md-search');\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Finds a filter by name.\n\t\t * @param {string} name - The name of the filter to find.\n\t\t * @returns {(FooTable.Filter|null)}\n\t\t */\n\t\tfind: function(name){\n\t\t\treturn F.arr.first(this.filters, function(f){ return f.name == name; });\n\t\t},\n\t\t/**\n\t\t * Gets an array of {@link FooTable.Column} to apply the search filter to. This also doubles as the default columns for filters which do not specify any columns.\n\t\t * @instance\n\t\t * @returns {Array.<FooTable.Column>}\n\t\t */\n\t\tcolumns: function(){\n\t\t\tif (F.is.jq(this.$dropdown)){\n\t\t\t\t// if we have a dropdown containing the column names get the selected columns from there\n\t\t\t\treturn this.$dropdown.find('input:checked').map(function(){\n\t\t\t\t\treturn $(this).data('__FooTableColumn__');\n\t\t\t\t}).get();\n\t\t\t} else {\n\t\t\t\t// otherwise find all columns that are set to be filterable.\n\t\t\t\treturn this.ft.columns.get(function(c){ return c.filterable; });\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Takes an array of plain objects containing the filter values or actual {@link FooTable.Filter} objects and ensures that an array of only {@link FooTable.Filter} is returned.\n\t\t * If supplied a plain object that object must contain a name, query and columns properties which are used to create a new {@link FooTable.Filter}.\n\t\t * @instance\n\t\t * @param {({name: string, query: (string|FooTable.Query), columns: (Array.<string>|Array.<number>|Array.<FooTable.Column>)}|Array.<FooTable.Filter>)} filters - The array of filters to check.\n\t\t * @returns {Array.<FooTable.Filter>}\n\t\t */\n\t\tensure: function(filters){\n\t\t\tvar self = this, parsed = [], filterable = self.columns();\n\t\t\tif (!F.is.emptyArray(filters)){\n\t\t\t\tF.arr.each(filters, function(f){\n\t\t\t\t\tf = self._ensure(f, filterable);\n\t\t\t\t\tif (f instanceof F.Filter) parsed.push(f);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn parsed;\n\t\t},\n\n\t\t/**\n\t\t * Creates a new filter using the supplied object or individual parameters to populate it.\n\t\t * @instance\n\t\t * @param {(string|FooTable.Filter|object)} nameOrObject - The name for the filter or the actual filter object itself.\n\t\t * @param {(string|FooTable.Query)} [query] - The query for the filter. This is only optional when the first parameter is a filter object.\n\t\t * @param {(Array.<number>|Array.<string>|Array.<FooTable.Column>)} [columns] - The columns to apply the filter to.\n\t\t * \tIf not supplied the filter will be applied to all selected columns in the search input dropdown.\n\t\t * @param {boolean} [ignoreCase=true] - Whether or not ignore case when matching.\n\t\t * @param {boolean} [connectors=true] - Whether or not to replace phrase connectors (+.-_) with spaces.\n\t\t * @param {string} [space=\"AND\"] - How the query treats space chars.\n\t\t * @param {boolean} [hidden=true] - Whether or not this is a hidden filter.\n\t\t * @returns {*}\n\t\t */\n\t\tcreateFilter: function(nameOrObject, query, columns, ignoreCase, connectors, space, hidden){\n\t\t\tif (F.is.string(nameOrObject)){\n\t\t\t\tnameOrObject = {name: nameOrObject, query: query, columns: columns, ignoreCase: ignoreCase, connectors: connectors, space: space, hidden: hidden};\n\t\t\t}\n\t\t\treturn this._ensure(nameOrObject, this.columns());\n\t\t},\n\n\t\t/* PRIVATE */\n\t\t_ensure: function(filter, selectedColumns){\n\t\t\tif ((F.is.hash(filter) || filter instanceof F.Filter) && !F.is.emptyString(filter.name) && (!F.is.emptyString(filter.query) || filter.query instanceof F.Query)){\n\t\t\t\tfilter.columns = F.is.emptyArray(filter.columns) ? selectedColumns : this.ft.columns.ensure(filter.columns);\n\t\t\t\tfilter.ignoreCase = F.is.boolean(filter.ignoreCase) ? filter.ignoreCase : this.ignoreCase;\n\t\t\t\tfilter.connectors = F.is.boolean(filter.connectors) ? filter.connectors : this.connectors;\n\t\t\t\tfilter.hidden = F.is.boolean(filter.hidden) ? filter.hidden : false;\n\t\t\t\tfilter.space = F.is.string(filter.space) && (filter.space === 'AND' || filter.space === 'OR') ? filter.space : this.space;\n\t\t\t\tfilter.query = F.is.string(filter.query) ? new F.Query(filter.query, filter.space, filter.connectors, filter.ignoreCase) : filter.query;\n\t\t\t\treturn (filter instanceof F.Filter)\n\t\t\t\t\t? filter\n\t\t\t\t\t: new F.Filter(filter.name, filter.query, filter.columns, filter.space, filter.connectors, filter.ignoreCase, filter.hidden);\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Handles the change event for the {@link FooTable.Filtering#$input}.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onSearchInputChanged: function (e) {\n\t\t\tvar self = e.data.self;\n\t\t\tvar alpha = e.type == 'keypress' && !F.is.emptyString(String.fromCharCode(e.charCode)),\n\t\t\t\tctrl = e.type == 'keyup' && (e.which == 8 || e.which == 46),\n\t\t\t\tpaste = e.type == 'paste'; // backspace & delete\n\n\t\t\t// if alphanumeric characters or specific control characters\n\t\t\tif(alpha || ctrl || paste) {\n\t\t\t\tif (e.which == 13) e.preventDefault();\n\t\t\t\tif (self._filterTimeout != null) clearTimeout(self._filterTimeout);\n\t\t\t\tself._filterTimeout = setTimeout(function(){\n\t\t\t\t\tself._filterTimeout = null;\n\t\t\t\t\tvar query = self.$input.val();\n\t\t\t\t\tif (query.length >= self.min){\n\t\t\t\t\t\tif (self.exactMatch && !self._exactRegExp.test(query)){\n\t\t\t\t\t\t\tquery = '\"' + query + '\"';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.addFilter('search', query);\n\t\t\t\t\t\tself.filter(self.focus);\n\t\t\t\t\t} else if (F.is.emptyString(query)){\n\t\t\t\t\t\tself.clear();\n\t\t\t\t\t}\n\t\t\t\t}, self.delay);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the click event for the {@link FooTable.Filtering#$button}.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onSearchButtonClicked: function (e) {\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self;\n\t\t\tif (self._filterTimeout != null) clearTimeout(self._filterTimeout);\n\t\t\tvar $icon = self.$button.children('.fooicon');\n\t\t\tif ($icon.hasClass('ion-md-close')) self.clear();\n\t\t\telse {\n\t\t\t\tvar query = self.$input.val();\n\t\t\t\tif (query.length >= self.min){\n\t\t\t\t\tif (self.exactMatch && !self._exactRegExp.test(query)){\n\t\t\t\t\t\tquery = '\"' + query + '\"';\n\t\t\t\t\t}\n\t\t\t\t\tself.addFilter('search', query);\n\t\t\t\t\tself.filter(self.focus);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the click event for the column checkboxes in the {@link FooTable.Filtering#$dropdown}.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onSearchColumnClicked: function (e) {\n\t\t\tvar self = e.data.self;\n\t\t\tif (self._filterTimeout != null) clearTimeout(self._filterTimeout);\n\t\t\tself._filterTimeout = setTimeout(function(){\n\t\t\t\tself._filterTimeout = null;\n\t\t\t\tvar $icon = self.$button.children('.fooicon');\n\t\t\t\tif ($icon.hasClass('ion-md-close')){\n\t\t\t\t\t$icon.removeClass('ion-md-close').addClass('ion-md-search');\n\t\t\t\t\tself.addFilter('search', self.$input.val());\n\t\t\t\t\tself.filter();\n\t\t\t\t}\n\t\t\t}, self.delay);\n\t\t},\n\t\t/**\n\t\t * Handles the click event for the {@link FooTable.Filtering#$dropdown} toggle.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onDropdownToggleClicked: function (e) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tvar self = e.data.self;\n\t\t\tself.$dropdown.parent().toggleClass('open');\n\t\t\tif (self.$dropdown.parent().hasClass('open')) $(document).on('click.footable', { self: self }, self._onDocumentClicked);\n\t\t\telse $(document).off('click.footable', self._onDocumentClicked);\n\t\t},\n\t\t/**\n\t\t * Checks all click events when the dropdown is visible and closes the menu if the target is not the dropdown.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onDocumentClicked: function(e){\n\t\t\tif ($(e.target).closest('.dropdown-menu').length == 0){\n\t\t\t\te.preventDefault();\n\t\t\t\tvar self = e.data.self;\n\t\t\t\tself.$dropdown.parent().removeClass('open');\n\t\t\t\t$(document).off('click.footable', self._onDocumentClicked);\n\t\t\t}\n\t\t}\n\t});\n\n\tF.components.register('filtering', F.Filtering, 500);\n\n})(jQuery, FooTable);\n\n(function(F){\n\tF.Query = F.Class.extend(/** @lends FooTable.Query */{\n\t\t/**\n\t\t * The query object is used to parse and test the filtering component's queries\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {string} query - The string value of the query.\n\t\t * @param {string} [space=\"AND\"] - How the query treats whitespace.\n\t\t * @param {boolean} [connectors=true] - Whether or not to replace phrase connectors (+.-_) with spaces.\n\t\t * @param {boolean} [ignoreCase=true] - Whether or not ignore case when matching.\n\t\t * @returns {FooTable.Query}\n\t\t */\n\t\tconstruct: function(query, space, connectors, ignoreCase){\n\t\t\t/* PRIVATE */\n\t\t\t/**\n\t\t\t * Holds the previous value of the query and is used internally in the {@link FooTable.Query#val} method.\n\t\t\t * @type {string}\n\t\t\t * @private\n\t\t\t */\n\t\t\tthis._original = null;\n\t\t\t/**\n\t\t\t * Holds the value for the query. Access to this variable is provided through the {@link FooTable.Query#val} method.\n\t\t\t * @type {string}\n\t\t\t * @private\n\t\t\t */\n\t\t\tthis._value = null;\n\t\t\t/* PUBLIC */\n\t\t\t/**\n\t\t\t * A string specifying how the query treats whitespace. Can be either \"OR\" or \"AND\".\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.space = F.is.string(space) && (space == 'OR' || space == 'AND') ? space : 'AND';\n\t\t\t/**\n\t\t\t * Whether or not to replace phrase connectors (+.-_) with spaces before executing the query.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.connectors = F.is.boolean(connectors) ? connectors : true;\n\t\t\t/**\n\t\t\t * Whether or not ignore case when matching.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.ignoreCase = F.is.boolean(ignoreCase) ? ignoreCase : true;\n\t\t\t/**\n\t\t\t * The left side of the query if one exists. OR takes precedence over AND.\n\t\t\t * @type {FooTable.Query}\n\t\t\t * @example <caption>The below shows what is meant by the \"left\" side of a query</caption>\n\t\t\t * query = \"Dave AND Mary\" - \"Dave\" is the left side of the query.\n\t\t\t * query = \"Dave AND Mary OR John\" - \"Dave and Mary\" is the left side of the query.\n\t\t\t */\n\t\t\tthis.left = null;\n\t\t\t/**\n\t\t\t * The right side of the query if one exists. OR takes precedence over AND.\n\t\t\t * @type {FooTable.Query}\n\t\t\t * @example <caption>The below shows what is meant by the \"right\" side of a query</caption>\n\t\t\t * query = \"Dave AND Mary\" - \"Mary\" is the right side of the query.\n\t\t\t * query = \"Dave AND Mary OR John\" - \"John\" is the right side of the query.\n\t\t\t */\n\t\t\tthis.right = null;\n\t\t\t/**\n\t\t\t * The parsed parts of the query. This contains the information used to actually perform a match against a string.\n\t\t\t * @type {Array}\n\t\t\t */\n\t\t\tthis.parts = [];\n\t\t\t/**\n\t\t\t * The type of operand to apply to the results of the individual parts of the query.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.operator = null;\n\t\t\tthis.val(query);\n\t\t},\n\t\t/**\n\t\t * Gets or sets the value for the query. During set the value is parsed setting all properties as required.\n\t\t * @param {string} [value] - If supplied the value to set for this query.\n\t\t * @returns {(string|undefined)}\n\t\t */\n\t\tval: function(value){\n\t\t\t// get\n\t\t\tif (F.is.emptyString(value)) return this._value;\n\n\t\t\t// set\n\t\t\tif (F.is.emptyString(this._original)) this._original = value;\n\t\t\telse if (this._original == value) return;\n\n\t\t\tthis._value = value;\n\t\t\tthis._parse();\n\t\t},\n\t\t/**\n\t\t * Tests the supplied string against the query.\n\t\t * @param {string} str - The string to test.\n\t\t * @returns {boolean}\n\t\t */\n\t\tmatch: function(str){\n\t\t\tif (F.is.emptyString(this.operator) || this.operator === 'OR')\n\t\t\t\treturn this._left(str, false) || this._match(str, false) || this._right(str, false);\n\t\t\tif (this.operator === 'AND')\n\t\t\t\treturn this._left(str, true) && this._match(str, true) && this._right(str, true);\n\t\t},\n\t\t/**\n\t\t * Matches this queries parts array against the supplied string.\n\t\t * @param {string} str - The string to test.\n\t\t * @param {boolean} def - The default value to return based on the operand.\n\t\t * @returns {boolean}\n\t\t * @private\n\t\t */\n\t\t_match: function(str, def){\n\t\t\tvar self = this, result = false, empty = F.is.emptyString(str);\n\t\t\tif (F.is.emptyArray(self.parts) && self.left instanceof F.Query) return def;\n\t\t\tif (F.is.emptyArray(self.parts)) return result;\n\t\t\tif (self.space === 'OR'){\n\t\t\t\t// with OR we give the str every part to test and if any match it is a success, we do exit early if a negated match occurs\n\t\t\t\tF.arr.each(self.parts, function(p){\n\t\t\t\t\tif (p.empty && empty){\n\t\t\t\t\t\tresult = true;\n\t\t\t\t\t\tif (p.negate){\n\t\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar match = (p.exact ? F.str.containsExact : F.str.contains)(str, p.query, self.ignoreCase);\n\t\t\t\t\t\tif (match && !p.negate) result = true;\n\t\t\t\t\t\tif (match && p.negate) {\n\t\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// otherwise with AND we check until the first failure and then exit\n\t\t\t\tresult = true;\n\t\t\t\tF.arr.each(self.parts, function(p){\n\t\t\t\t\tif (p.empty){\n\t\t\t\t\t\tif ((!empty && !p.negate) || (empty && p.negate)) result = false;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar match = (p.exact ? F.str.containsExact : F.str.contains)(str, p.query, self.ignoreCase);\n\t\t\t\t\t\tif ((!match && !p.negate) || (match && p.negate)) result = false;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * Matches the left side of the query if one exists with the supplied string.\n\t\t * @param {string} str - The string to test.\n\t\t * @param {boolean} def - The default value to return based on the operand.\n\t\t * @returns {boolean}\n\t\t * @private\n\t\t */\n\t\t_left: function(str, def){\n\t\t\treturn (this.left instanceof F.Query) ? this.left.match(str) : def;\n\t\t},\n\t\t/**\n\t\t * Matches the right side of the query if one exists with the supplied string.\n\t\t * @param {string} str - The string to test.\n\t\t * @param {boolean} def - The default value to return based on the operand.\n\t\t * @returns {boolean}\n\t\t * @private\n\t\t */\n\t\t_right: function(str, def){\n\t\t\treturn (this.right instanceof F.Query) ? this.right.match(str) : def;\n\t\t},\n\t\t/**\n\t\t * Parses the private {@link FooTable.Query#_value} property and populates the object.\n\t\t * @private\n\t\t */\n\t\t_parse: function(){\n\t\t\tif (F.is.emptyString(this._value)) return;\n\t\t\t// OR takes precedence so test for it first\n\t\t\tif (/\\sOR\\s/.test(this._value)){\n\t\t\t\t// we have an OR so split the value on the first occurrence of OR to get the left and right sides of the statement\n\t\t\t\tthis.operator = 'OR';\n\t\t\t\tvar or = this._value.split(/(?:\\sOR\\s)(.*)?/);\n\t\t\t\tthis.left = new F.Query(or[0], this.space, this.connectors, this.ignoreCase);\n\t\t\t\tthis.right = new F.Query(or[1], this.space, this.connectors, this.ignoreCase);\n\t\t\t} else if (/\\sAND\\s/.test(this._value)) {\n\t\t\t\t// there are no more OR's so start with AND\n\t\t\t\tthis.operator = 'AND';\n\t\t\t\tvar and = this._value.split(/(?:\\sAND\\s)(.*)?/);\n\t\t\t\tthis.left = new F.Query(and[0], this.space, this.connectors, this.ignoreCase);\n\t\t\t\tthis.right = new F.Query(and[1], this.space, this.connectors, this.ignoreCase);\n\t\t\t} else {\n\t\t\t\t// we have no more statements to parse so set the parts array by parsing each part of the remaining query\n\t\t\t\tvar self = this;\n\t\t\t\tthis.parts = F.arr.map(this._value.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g), function(str){\n\t\t\t\t\treturn self._part(str);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Parses a single part of a query into an object to use during matching.\n\t\t * @param {string} str - The string representation of the part.\n\t\t * @returns {{query: string, negate: boolean, phrase: boolean, exact: boolean}}\n\t\t * @private\n\t\t */\n\t\t_part: function(str){\n\t\t\tvar p = {\n\t\t\t\tquery: str,\n\t\t\t\tnegate: false,\n\t\t\t\tphrase: false,\n\t\t\t\texact: false,\n\t\t\t\tempty: false\n\t\t\t};\n\t\t\t// support for NEGATE operand - (minus sign). Remove this first so we can get onto phrase checking\n\t\t\tif (F.str.startsWith(p.query, '-')){\n\t\t\t\tp.query = F.str.from(p.query, '-');\n\t\t\t\tp.negate = true;\n\t\t\t}\n\t\t\t// support for PHRASES (exact matches)\n\t\t\tif (/^\"(.*?)\"$/.test(p.query)){ // if surrounded in quotes strip them and nothing else\n\t\t\t\tp.query = p.query.replace(/^\"(.*?)\"$/, '$1');\n\t\t\t\tp.phrase = true;\n\t\t\t\tp.exact = true;\n\t\t\t} else if (this.connectors && /(?:\\w)+?([-_\\+\\.])(?:\\w)+?/.test(p.query)) { // otherwise replace supported phrase connectors (-_+.) with spaces\n\t\t\t\tp.query = p.query.replace(/(?:\\w)+?([-_\\+\\.])(?:\\w)+?/g, function(match, p1){\n\t\t\t\t\treturn match.replace(p1, ' ');\n\t\t\t\t});\n\t\t\t\tp.phrase = true;\n\t\t\t}\n\t\t\tp.empty = p.phrase && F.is.emptyString(p.query);\n\t\t\treturn p;\n\t\t}\n\t});\n\n})(FooTable);\n(function(F){\n\n\t/**\n\t * The value used by the filtering component during filter operations. Must be a string and can be set using the data-filter-value attribute on the cell itself.\n\t * If this is not supplied it is set to the result of the toString method called on the value for the cell. Added by the {@link FooTable.Filtering} component.\n\t * @type {string}\n\t * @default null\n\t */\n\tF.Cell.prototype.filterValue = null;\n\n\t// this is used to define the filtering specific properties on cell creation\n\tF.Cell.prototype.__filtering_define__ = function(valueOrElement){\n\t\tthis.filterValue = this.column.filterValue.call(this.column, valueOrElement);\n\t};\n\n\t// this is used to update the filterValue property whenever the cell value is changed\n\tF.Cell.prototype.__filtering_val__ = function(value){\n\t\tif (F.is.defined(value)){\n\t\t\t// set only\n\t\t\tthis.filterValue = this.column.filterValue.call(this.column, value);\n\t\t}\n\t};\n\n\t// overrides the public define method and replaces it with our own\n\tF.Cell.extend('define', function(valueOrElement){\n\t\tthis._super(valueOrElement);\n\t\tthis.__filtering_define__(valueOrElement);\n\t});\n\t// overrides the public val method and replaces it with our own\n\tF.Cell.extend('val', function(value, redraw, redrawSelf){\n\t\tvar val = this._super(value, redraw, redrawSelf);\n\t\tthis.__filtering_val__(value);\n\t\treturn val;\n\t});\n})(FooTable);\n(function($, F){\n\t/**\n\t * Whether or not the column can be used during filtering. Added by the {@link FooTable.Filtering} component.\n\t * @type {boolean}\n\t * @default true\n\t */\n\tF.Column.prototype.filterable = true;\n\n\t/**\n\t * This is supplied either the cell value or jQuery object to parse. A string value must be returned from this method and will be used during filtering operations.\n\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t * @returns {string}\n\t * @this FooTable.Column\n\t */\n\tF.Column.prototype.filterValue = function(valueOrElement){\n\t\t// if we have an element or a jQuery object use jQuery to get the value\n\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){\n\t\t\tvar data = $(valueOrElement).data('filterValue');\n\t\t\treturn F.is.defined(data) ? ''+data : $(valueOrElement).text();\n\t\t}\n\t\t// if options are supplied with the value\n\t\tif (F.is.hash(valueOrElement) && F.is.hash(valueOrElement.options)){\n\t\t\tif (F.is.string(valueOrElement.options.filterValue)) return valueOrElement.options.filterValue;\n\t\t\tif (F.is.defined(valueOrElement.value)) valueOrElement = valueOrElement.value;\n\t\t}\n\t\tif (F.is.defined(valueOrElement) && valueOrElement != null) return valueOrElement+''; // use the native toString of the value\n\t\treturn ''; // otherwise we have no value so return an empty string\n\t};\n\n\t// this is used to define the filtering specific properties on column creation\n\tF.Column.prototype.__filtering_define__ = function(definition){\n\t\tthis.filterable = F.is.boolean(definition.filterable) ? definition.filterable : this.filterable;\n\t\tthis.filterValue = F.checkFnValue(this, definition.filterValue, this.filterValue);\n\t};\n\n\t// overrides the public define method and replaces it with our own\n\tF.Column.extend('define', function(definition){\n\t\tthis._super(definition); // call the base so we don't have to redefine any previously set properties\n\t\tthis.__filtering_define__(definition); // then call our own\n\t});\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * An object containing the filtering options for the plugin. Added by the {@link FooTable.Filtering} component.\n\t * @type {object}\n\t * @prop {boolean} enabled=false - Whether or not to allow filtering on the table.\n\t * @prop {({name: string, query: (string|FooTable.Query), columns: (Array.<string>|Array.<number>|Array.<FooTable.Column>)}|Array.<FooTable.Filter>)} filters - The filters to apply to the current {@link FooTable.Rows#array}.\n\t * @prop {number} delay=1200 - The delay in milliseconds before the query is auto applied after a change (any value equal to or less than zero will disable this).\n\t * @prop {number} min=1 - The minimum number of characters allowed in the search input before it is auto applied.\n\t * @prop {string} space=\"AND\" - Specifies how whitespace in a filter query is handled.\n\t * @prop {string} placeholder=\"Search\" - The string used as the placeholder for the search input.\n\t * @prop {string} dropdownTitle=null - The title to display at the top of the search input column select.\n\t * @prop {string} position=\"right\" - The string used to specify the alignment of the search input.\n\t * @prop {string} connectors=true - Whether or not to replace phrase connectors (+.-_) with space before executing the query.\n\t * @prop {boolean} ignoreCase=true - Whether or not ignore case when matching.\n\t * @prop {boolean} exactMatch=false - Whether or not search queries are treated as phrases when matching.\n\t * @prop {boolean} focus=true - Whether or not to focus the search input after the search/clear button is clicked or after auto applying the search input query.\n\t * @prop {string} container=null - A selector specifying where to place the filtering components form, if null the form is displayed within a row in the head of the table.\n\t */\n\tF.Defaults.prototype.filtering = {\n\t\tenabled: false,\n\t\tfilters: [],\n\t\tdelay: 1200,\n\t\tmin: 1,\n\t\tspace: 'AND',\n\t\tplaceholder: 'Search',\n\t\tdropdownTitle: null,\n\t\tposition: 'right',\n\t\tconnectors: true,\n\t\tignoreCase: true,\n\t\texactMatch: false,\n\t\tfocus: true,\n\t\tcontainer: null\n\t};\n})(FooTable);\n(function(F){\n\t/**\n\t * Checks if the row is filtered using the supplied filters.\n\t * @this FooTable.Row\n\t * @param {Array.<FooTable.Filter>} filters - The filters to apply.\n\t * @returns {boolean}\n\t */\n\tF.Row.prototype.filtered = function(filters){\n\t\tvar result = true, self = this;\n\t\tF.arr.each(filters, function(f){\n\t\t\tif ((result = f.matchRow(self)) == false) return false;\n\t\t});\n\t\treturn result;\n\t};\n})(FooTable);\n(function($, F){\n\n\tF.Sorter = F.Class.extend(/** @lends FooTable.Sorter */{\n\t\t/**\n\t\t * The sorter object contains the column and direction to sort by.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {FooTable.Column} column - The column to sort.\n\t\t * @param {string} direction - The direction to sort by.\n\t\t * @returns {FooTable.Sorter}\n\t\t */\n\t\tconstruct: function(column, direction){\n\t\t\t/**\n\t\t\t * The column to sort.\n\t\t\t * @type {FooTable.Column}\n\t\t\t */\n\t\t\tthis.column = column;\n\t\t\t/**\n\t\t\t * The direction to sort by.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.direction = direction;\n\t\t}\n\t});\n\n})(jQuery, FooTable);\n(function ($, F) {\n\tF.Sorting = F.Component.extend(/** @lends FooTable.Sorting */{\n\t\t/**\n\t\t * The sorting component adds a small sort button to specified column headers allowing users to sort those columns in the table.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table - The parent {@link FooTable.Table} object for the component.\n\t\t * @returns {FooTable.Sorting}\n\t\t */\n\t\tconstruct: function (table) {\n\t\t\t// call the constructor of the base class\n\t\t\tthis._super(table, table.o.sorting.enabled);\n\n\t\t\t/* PROTECTED */\n\t\t\t/**\n\t\t\t * This provides a shortcut to the {@link FooTable.Table#options}.[sorting]{@link FooTable.Defaults#sorting} object.\n\t\t\t * @instance\n\t\t\t * @protected\n\t\t\t * @type {object}\n\t\t\t */\n\t\t\tthis.o = table.o.sorting;\n\t\t\t/**\n\t\t\t * The current sorted column.\n\t\t\t * @instance\n\t\t\t * @type {FooTable.Column}\n\t\t\t */\n\t\t\tthis.column = null;\n\t\t\t/**\n\t\t\t * Whether or not to allow sorting to occur, should be set using the {@link FooTable.Sorting#toggleAllowed} method.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.allowed = true;\n\t\t\t/**\n\t\t\t * The initial sort state of the table, this value is used for determining if the sorting has occurred or to reset the state to default.\n\t\t\t * @instance\n\t\t\t * @type {{isset: boolean, rows: Array.<FooTable.Row>, column: string, direction: ?string}}\n\t\t\t */\n\t\t\tthis.initial = null;\n\t\t},\n\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * Checks the supplied data and options for the sorting component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the parent table.\n\t\t * @fires FooTable.Sorting#\"preinit.ft.sorting\"\n\t\t * @this FooTable.Sorting\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.sorting event is raised before the UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Sorting#\"preinit.ft.sorting\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\tthis.ft.raise('preinit.ft.sorting', [data]).then(function(){\n\t\t\t\tif (self.ft.$el.hasClass('footable-sorting'))\n\t\t\t\t\tself.enabled = true;\n\t\t\t\tself.enabled = F.is.boolean(data.sorting)\n\t\t\t\t\t? data.sorting\n\t\t\t\t\t: self.enabled;\n\t\t\t\tif (!self.enabled) return;\n\t\t\t\tself.column = F.arr.first(self.ft.columns.array, function(col){ return col.sorted; });\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the sorting component for the plugin using the supplied table and options.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Sorting#\"init.ft.sorting\"\n\t\t * @this FooTable.Sorting\n\t\t */\n\t\tinit: function () {\n\t\t\t/**\n\t\t\t * The init.ft.sorting event is raised before its UI is generated.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Sorting#\"init.ft.sorting\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('init.ft.sorting').then(function(){\n\t\t\t\tif (!self.initial){\n\t\t\t\t\tvar isset = !!self.column;\n\t\t\t\t\tself.initial = {\n\t\t\t\t\t\tisset: isset,\n\t\t\t\t\t\t// grab a shallow copy of the rows array prior to sorting - allows us to reset without an initial sort\n\t\t\t\t\t\trows: self.ft.rows.all.slice(0),\n\t\t\t\t\t\t// if there is a sorted column store its name and direction\n\t\t\t\t\t\tcolumn: isset ? self.column.name : null,\n\t\t\t\t\t\tdirection: isset ? self.column.direction : null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tF.arr.each(self.ft.columns.array, function(col){\n\t\t\t\t\tif (col.sortable){\n\t\t\t\t\t\tcol.$el.addClass('footable-sortable').append($('<span/>', {'class': 'fooicon fooicon-sort'}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tself.ft.$el.on('click.footable', '.footable-sortable', { self: self }, self._onSortClicked);\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys the sorting component removing any UI generated from the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Sorting#\"destroy.ft.sorting\"\n\t\t */\n\t\tdestroy: function () {\n\t\t\t/**\n\t\t\t * The destroy.ft.sorting event is raised before its UI is removed.\n\t\t\t * Calling preventDefault on this event will prevent the component from being destroyed.\n\t\t\t * @event FooTable.Sorting#\"destroy.ft.sorting\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('destroy.ft.paging').then(function(){\n\t\t\t\tself.ft.$el.off('click.footable', '.footable-sortable', self._onSortClicked);\n\t\t\t\tself.ft.$el.children('thead').children('tr.footable-header')\n\t\t\t\t\t.children('.footable-sortable').removeClass('footable-sortable footable-asc footable-desc')\n\t\t\t\t\t.find('span.fooicon').remove();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Performs the actual sorting against the {@link FooTable.Rows#current} array.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tpredraw: function () {\n\t\t\tif (!this.column) return;\n\t\t\tvar self = this, col = self.column;\n\t\t\tself.ft.rows.array.sort(function (a, b) {\n\t\t\t\treturn col.direction == 'DESC'\n\t\t\t\t\t\t? col.sorter(b.cells[col.index].sortValue, a.cells[col.index].sortValue)\n\t\t\t\t\t\t: col.sorter(a.cells[col.index].sortValue, b.cells[col.index].sortValue);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Updates the sorting UI setting the state of the sort buttons.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tdraw: function () {\n\t\t\tif (!this.column) return;\n\t\t\tvar self = this,\n\t\t\t\t$sortable = self.ft.$el.find('thead > tr > .footable-sortable'),\n\t\t\t\t$active = self.column.$el;\n\n\t\t\t$sortable.removeClass('footable-asc footable-desc').children('.fooicon').removeClass('fooicon-sort fooicon-sort-asc fooicon-sort-desc');\n\t\t\t$sortable.not($active).children('.fooicon').addClass('fooicon-sort');\n\t\t\t$active.addClass(self.column.direction == 'DESC' ? 'footable-desc' : 'footable-asc')\n\t\t\t\t.children('.fooicon').addClass(self.column.direction == 'DESC' ? 'fooicon-sort-desc' : 'fooicon-sort-asc');\n\t\t},\n\n\t\t/* PUBLIC */\n\t\t/**\n\t\t * Sets the sorting options and calls the {@link FooTable.Table#draw} method to perform the actual sorting.\n\t\t * @instance\n\t\t * @param {(string|number|FooTable.Column)} column - The column name, index or the actual {@link FooTable.Column} object to sort by.\n\t\t * @param {string} [direction=\"ASC\"] - The direction to sort by, either ASC or DESC.\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Sorting#\"before.ft.sorting\"\n\t\t * @fires FooTable.Sorting#\"after.ft.sorting\"\n\t\t */\n\t\tsort: function(column, direction){\n\t\t\treturn this._sort(column, direction);\n\t\t},\n\t\t/**\n\t\t * Toggles whether or not sorting is currently allowed.\n\t\t * @param {boolean} [state] - You can optionally specify the state you want it to be, if not supplied the current value is flipped.\n\t\t */\n\t\ttoggleAllowed: function(state){\n\t\t\tstate = F.is.boolean(state) ? state : !this.allowed;\n\t\t\tthis.allowed = state;\n\t\t\tthis.ft.$el.toggleClass('footable-sorting-disabled', !this.allowed);\n\t\t},\n\t\t/**\n\t\t * Checks whether any sorting has occurred for the table.\n\t\t * @returns {boolean}\n\t\t */\n\t\thasChanged: function(){\n\t\t\treturn !(!this.initial || !this.column ||\n\t\t\t\t(this.column.name === this.initial.column &&\n\t\t\t\t\t(this.column.direction === this.initial.direction || (this.initial.direction === null && this.column.direction === 'ASC')))\n\t\t\t);\n\t\t},\n\t\t/**\n\t\t * Resets the table sorting to the initial state recorded in the components init method.\n\t\t */\n\t\treset: function(){\n\t\t\tif (!!this.initial){\n\t\t\t\tif (this.initial.isset){\n\t\t\t\t\t// if the initial value specified a column, sort by it\n\t\t\t\t\tthis.sort(this.initial.column, this.initial.direction);\n\t\t\t\t} else {\n\t\t\t\t\t// if there was no initial column then we need to reset the rows to there original order\n\t\t\t\t\tif (!!this.column){\n\t\t\t\t\t\t// if there is a currently sorted column remove the asc/desc classes and set it to null.\n\t\t\t\t\t\tthis.column.$el.removeClass('footable-asc footable-desc');\n\t\t\t\t\t\tthis.column = null;\n\t\t\t\t\t}\n\t\t\t\t\t// replace the current all rows array with the one stored in the initial value\n\t\t\t\t\tthis.ft.rows.all = this.initial.rows;\n\t\t\t\t\t// force the table to redraw itself using the updated rows array\n\t\t\t\t\tthis.ft.draw();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/* PRIVATE */\n\t\t/**\n\t\t * Performs the required steps to handle sorting including the raising of the {@link FooTable.Sorting#\"before.ft.sorting\"} and {@link FooTable.Sorting#\"after.ft.sorting\"} events.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {(string|number|FooTable.Column)} column - The column name, index or the actual {@link FooTable.Column} object to sort by.\n\t\t * @param {string} [direction=\"ASC\"] - The direction to sort by, either ASC or DESC.\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Sorting#\"before.ft.sorting\"\n\t\t * @fires FooTable.Sorting#\"after.ft.sorting\"\n\t\t */\n\t\t_sort: function(column, direction){\n\t\t\tif (!this.allowed) return $.Deferred().reject('sorting disabled');\n\t\t\tvar self = this;\n\t\t\tvar sorter = new F.Sorter(self.ft.columns.get(column), F.Sorting.dir(direction));\n\t\t\t/**\n\t\t\t * The before.ft.sorting event is raised before a sort is applied and allows listeners to modify the sorter or cancel it completely by calling preventDefault on the jQuery.Event object.\n\t\t\t * @event FooTable.Sorting#\"before.ft.sorting\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {FooTable.Sorter} sorter - The sorter that is about to be applied.\n\t\t\t */\n\t\t\treturn self.ft.raise('before.ft.sorting', [sorter]).then(function(){\n\t\t\t\tF.arr.each(self.ft.columns.array, function(col){\n\t\t\t\t\tif (col != self.column) col.direction = null;\n\t\t\t\t});\n\t\t\t\tself.column = self.ft.columns.get(sorter.column);\n\t\t\t\tif (self.column) self.column.direction = F.Sorting.dir(sorter.direction);\n\t\t\t\treturn self.ft.draw().then(function(){\n\t\t\t\t\t/**\n\t\t\t\t\t * The after.ft.sorting event is raised after a sorter has been applied.\n\t\t\t\t\t * @event FooTable.Sorting#\"after.ft.sorting\"\n\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t * @param {FooTable.Sorter} sorter - The sorter that has been applied.\n\t\t\t\t\t */\n\t\t\t\t\tself.ft.raise('after.ft.sorting', [sorter]);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Handles the sort button clicked event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onSortClicked: function (e) {\n\t\t\tvar self = e.data.self, $header = $(this).closest('th,td'),\n\t\t\t\tdirection = $header.is('.footable-asc, .footable-desc')\n\t\t\t\t\t? ($header.hasClass('footable-desc') ? 'ASC' : 'DESC')\n\t\t\t\t\t: 'ASC';\n\t\t\tself._sort($header.index(), direction);\n\t\t}\n\t});\n\n\t/**\n\t * Checks the supplied string is a valid direction and if not returns ASC as default.\n\t * @static\n\t * @protected\n\t * @param {string} str - The string to check.\n\t */\n\tF.Sorting.dir = function(str){\n\t\treturn F.is.string(str) && (str == 'ASC' || str == 'DESC') ? str : 'ASC';\n\t};\n\n\tF.components.register('sorting', F.Sorting, 600);\n\n})(jQuery, FooTable);\n(function(F){\n\n\t/**\n\t * The value used by the sorting component during sort operations. Can be set using the data-sort-value attribute on the cell itself.\n\t * If this is not supplied it is set to the result of the toString method called on the value for the cell. Added by the {@link FooTable.Sorting} component.\n\t * @type {string}\n\t * @default null\n\t */\n\tF.Cell.prototype.sortValue = null;\n\n\t// this is used to define the sorting specific properties on cell creation\n\tF.Cell.prototype.__sorting_define__ = function(valueOrElement){\n\t\tthis.sortValue = this.column.sortValue.call(this.column, valueOrElement);\n\t};\n\n\t// this is used to update the sortValue property whenever the cell value is changed\n\tF.Cell.prototype.__sorting_val__ = function(value){\n\t\tif (F.is.defined(value)){\n\t\t\t// set only\n\t\t\tthis.sortValue = this.column.sortValue.call(this.column, value);\n\t\t}\n\t};\n\n\t// overrides the public define method and replaces it with our own\n\tF.Cell.extend('define', function(valueOrElement){\n\t\tthis._super(valueOrElement);\n\t\tthis.__sorting_define__(valueOrElement);\n\t});\n\t// overrides the public val method and replaces it with our own\n\tF.Cell.extend('val', function(value, redraw, redrawSelf){\n\t\tvar val = this._super(value, redraw, redrawSelf);\n\t\tthis.__sorting_val__(value);\n\t\treturn val;\n\t});\n})(FooTable);\n(function($, F){\n\t/**\n\t * The direction to sort if the {@link FooTable.Column#sorted} property is set to true. Can be \"ASC\", \"DESC\" or NULL. Added by the {@link FooTable.Sorting} component.\n\t * @type {string}\n\t * @default null\n\t */\n\tF.Column.prototype.direction = null;\n\t/**\n\t * Whether or not the column can be sorted. Added by the {@link FooTable.Sorting} component.\n\t * @type {boolean}\n\t * @default true\n\t */\n\tF.Column.prototype.sortable = true;\n\t/**\n\t * Whether or not the column is sorted. Added by the {@link FooTable.Sorting} component.\n\t * @type {boolean}\n\t * @default false\n\t */\n\tF.Column.prototype.sorted = false;\n\n\t/**\n\t * This is supplied two values from the column for a comparison to be made and the result returned. Added by the {@link FooTable.Sorting} component.\n\t * @param {*} a - The first value to be compared.\n\t * @param {*} b - The second value to compare to the first.\n\t * @returns {number}\n\t * @example <caption>This example shows using pseudo code what a sort function would look like.</caption>\n\t * \"sorter\": function(a, b){\n\t * \tif (a is less than b by some ordering criterion) {\n\t * \t\treturn -1;\n\t * \t}\n\t * \tif (a is greater than b by the ordering criterion) {\n\t * \t\treturn 1;\n\t * \t}\n\t * \t// a must be equal to b\n\t * \treturn 0;\n\t * }\n\t */\n\tF.Column.prototype.sorter = function(a, b){\n\t\tif (typeof a === 'string') a = a.toLowerCase();\n\t\tif (typeof b === 'string') b = b.toLowerCase();\n\t\tif (a === b) return 0;\n\t\tif (a < b) return -1;\n\t\treturn 1;\n\t};\n\n\t/**\n\t * This is supplied either the cell value or jQuery object to parse. A value must be returned from this method and will be used during sorting operations.\n\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t * @returns {*}\n\t * @this FooTable.Column\n\t */\n\tF.Column.prototype.sortValue = function(valueOrElement){\n\t\t// if we have an element or a jQuery object use jQuery to get the value\n\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){\n\t\t\tvar data = $(valueOrElement).data('sortValue');\n\t\t\treturn F.is.defined(data) ? data : this.parser(valueOrElement);\n\t\t}\n\t\t// if options are supplied with the value\n\t\tif (F.is.hash(valueOrElement) && F.is.hash(valueOrElement.options)){\n\t\t\tif (F.is.string(valueOrElement.options.sortValue)) return valueOrElement.options.sortValue;\n\t\t\tif (F.is.defined(valueOrElement.value)) valueOrElement = valueOrElement.value;\n\t\t}\n\t\tif (F.is.defined(valueOrElement) && valueOrElement != null) return valueOrElement;\n\t\treturn null;\n\t};\n\n\t// this is used to define the sorting specific properties on column creation\n\tF.Column.prototype.__sorting_define__ = function(definition){\n\t\tthis.sorter = F.checkFnValue(this, definition.sorter, this.sorter);\n\t\tthis.direction = F.is.type(definition.direction, 'string') ? F.Sorting.dir(definition.direction) : null;\n\t\tthis.sortable = F.is.boolean(definition.sortable) ? definition.sortable : true;\n\t\tthis.sorted = F.is.boolean(definition.sorted) ? definition.sorted : false;\n\t\tthis.sortValue = F.checkFnValue(this, definition.sortValue, this.sortValue);\n\t};\n\n\t// overrides the public define method and replaces it with our own\n\tF.Column.extend('define', function(definition){\n\t\tthis._super(definition);\n\t\tthis.__sorting_define__(definition);\n\t});\n\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * An object containing the sorting options for the plugin. Added by the {@link FooTable.Sorting} component.\n\t * @type {object}\n\t * @prop {boolean} enabled=false - Whether or not to allow sorting on the table.\n\t */\n\tF.Defaults.prototype.sorting = {\n\t\tenabled: false\n\t};\n})(FooTable);\n(function($, F){\n\n\tF.HTMLColumn.extend('__sorting_define__', function(definition){\n\t\tthis._super(definition);\n\t\tthis.sortUse = F.is.string(definition.sortUse) && $.inArray(definition.sortUse, ['html','text']) !== -1 ? definition.sortUse : 'html';\n\t});\n\n\t/**\n\t * This is supplied either the cell value or jQuery object to parse. A value must be returned from this method and will be used during sorting operations.\n\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t * @returns {*}\n\t * @this FooTable.HTMLColumn\n\t */\n\tF.HTMLColumn.prototype.sortValue = function(valueOrElement){\n\t\t// if we have an element or a jQuery object use jQuery to get the data value or pass it off to the parser\n\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){\n\t\t\tvar data = $(valueOrElement).data('sortValue');\n\t\t\treturn F.is.defined(data) ? data : this.parser(valueOrElement);\n\t\t}\n\t\t// if options are supplied with the value\n\t\tif (F.is.hash(valueOrElement) && F.is.hash(valueOrElement.options)){\n\t\t\tif (F.is.string(valueOrElement.options.sortValue)) return valueOrElement.options.sortValue;\n\t\t\tif (F.is.defined(valueOrElement.value)) valueOrElement = valueOrElement.value;\n\t\t}\n\t\tif (F.is.defined(valueOrElement) && valueOrElement != null) return valueOrElement;\n\t\treturn null;\n\t};\n\n})(jQuery, FooTable);\n(function($, F){\n\n\t/**\n\t * This is supplied either the cell value or jQuery object to parse. A value must be returned from this method and will be used during sorting operations.\n\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t * @returns {*}\n\t */\n\tF.NumberColumn.prototype.sortValue = function(valueOrElement){\n\t\t// if we have an element or a jQuery object use jQuery to get the data value or pass it off to the parser\n\t\tif (F.is.element(valueOrElement) || F.is.jq(valueOrElement)){\n\t\t\tvar data = $(valueOrElement).data('sortValue');\n\t\t\treturn F.is.number(data) ? data : this.parser(valueOrElement);\n\t\t}\n\t\t// if options are supplied with the value\n\t\tif (F.is.hash(valueOrElement) && F.is.hash(valueOrElement.options)){\n\t\t\tif (F.is.string(valueOrElement.options.sortValue)) return this.parser(valueOrElement);\n\t\t\tif (F.is.number(valueOrElement.options.sortValue)) return valueOrElement.options.sortValue;\n\t\t\tif (F.is.number(valueOrElement.value)) return valueOrElement.value;\n\t\t}\n\t\tif (F.is.string(valueOrElement)) return this.parser(valueOrElement);\n\t\tif (F.is.number(valueOrElement)) return valueOrElement;\n\t\treturn null;\n\t};\n\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * Sort the table using the specified column and direction. Added by the {@link FooTable.Sorting} component.\n\t * @instance\n\t * @param {(string|number|FooTable.Column)} column - The column name, index or the actual {@link FooTable.Column} object to sort by.\n\t * @param {string} [direction=\"ASC\"] - The direction to sort by, either ASC or DESC.\n\t * @returns {jQuery.Promise}\n\t * @fires FooTable.Sorting#\"change.ft.sorting\"\n\t * @fires FooTable.Sorting#\"changed.ft.sorting\"\n\t * @see FooTable.Sorting#sort\n\t */\n\tF.Table.prototype.sort = function(column, direction){\n\t\treturn this.use(F.Sorting).sort(column, direction);\n\t};\n})(FooTable);\n(function($, F){\n\n\tF.Pager = F.Class.extend(/** @lends FooTable.Pager */{\n\t\t/**\n\t\t * The pager object contains the page number and direction to page to.\n\t\t * @constructs\n\t\t * @extends FooTable.Class\n\t\t * @param {number} total - The total number of pages available.\n\t\t * @param {number} current - The current page number.\n\t\t * @param {number} size - The number of rows per page.\n\t\t * @param {number} page - The page number to goto.\n\t\t * @param {boolean} forward - A boolean indicating the direction of paging, TRUE = forward, FALSE = back.\n\t\t * @returns {FooTable.Pager}\n\t\t */\n\t\tconstruct: function(total, current, size, page, forward){\n\t\t\t/**\n\t\t\t * The total number of pages available.\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.total = total;\n\t\t\t/**\n\t\t\t * The current page number.\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.current = current;\n\t\t\t/**\n\t\t\t * The number of rows per page.\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.size = size;\n\t\t\t/**\n\t\t\t * The page number to goto.\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.page = page;\n\t\t\t/**\n\t\t\t * A boolean indicating the direction of paging, TRUE = forward, FALSE = back.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.forward = forward;\n\t\t}\n\t});\n\n})(jQuery, FooTable);\n(function($, F){\n\tF.Paging = F.Component.extend(/** @lends FooTable.Paging */{\n\t\t/**\n\t\t * The paging component adds a pagination control to the table allowing users to navigate table rows via pages.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table - The parent {@link FooTable.Table} object for the component.\n\t\t * @returns {FooTable.Filtering}\n\t\t */\n\t\tconstruct: function(table){\n\t\t\t// call the base constructor\n\t\t\tthis._super(table, table.o.paging.enabled);\n\n\t\t\t/* PROTECTED */\n\t\t\t/**\n\t\t\t * An object containing the strings used by the paging buttons.\n\t\t\t * @type {{ first: string, prev: string, next: string, last: string }}\n\t\t\t */\n\t\t\tthis.strings = table.o.paging.strings;\n\n\t\t\t/* PUBLIC */\n\t\t\t/**\n\t\t\t * The current page number to display.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.current = table.o.paging.current;\n\t\t\t/**\n\t\t\t * The number of rows to display per page.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.size = table.o.paging.size;\n\t\t\t/**\n\t\t\t * The maximum number of page links to display at once.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.limit = table.o.paging.limit;\n\t\t\t/**\n\t\t\t * The position of the pagination control within the paging rows cell.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.position = table.o.paging.position;\n\t\t\t/**\n\t\t\t * The format string used to generate the text displayed under the pagination control.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.countFormat = table.o.paging.countFormat;\n\t\t\t/**\n\t\t\t * A selector specifying where to place the paging components UI, if null the UI is displayed within a row in the foot of the table.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.container = table.o.paging.container;\n\t\t\t\t/**\n\t\t\t * The total number of pages.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.total = -1;\n\t\t\t/**\n\t\t\t * The number of rows in the {@link FooTable.Rows#array} before paging is applied.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.totalRows = 0;\n\t\t\t/**\n\t\t\t * A number indicating the previous page displayed.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.previous = -1;\n\t\t\t/**\n\t\t\t * The count string generated using the {@link FooTable.Filtering#countFormat} option. This value is only set after the first call to the {@link FooTable.Filtering#predraw} method.\n\t\t\t * @instance\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.formattedCount = null;\n\t\t\t/**\n\t\t\t * The jQuery object of the element containing the entire paging UI.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$container = null;\n\t\t\t/**\n\t\t\t * The jQuery object of the element wrapping all the paging UI elements.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$wrapper = null;\n\t\t\t/** +\n\t\t\t * The jQuery row object that contains all the paging specific elements.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$row = null;\n\t\t\t/**\n\t\t\t * The jQuery cell object that contains the pagination control and total count.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$cell = null;\n\t\t\t/**\n\t\t\t * The jQuery object that contains the links for the pagination control.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$pagination = null;\n\t\t\t/**\n\t\t\t * The jQuery object that contains the row count.\n\t\t\t * @instance\n\t\t\t * @type {jQuery}\n\t\t\t */\n\t\t\tthis.$count = null;\n\t\t\t/**\n\t\t\t * Whether or not the pagination row is detached from the table.\n\t\t\t * @instance\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.detached = true;\n\n\t\t\t/* PRIVATE */\n\t\t\t/**\n\t\t\t * Used to hold the number of page links created.\n\t\t\t * @instance\n\t\t\t * @type {number}\n\t\t\t * @private\n\t\t\t */\n\t\t\tthis._createdLinks = 0;\n\t\t},\n\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * Checks the supplied data and options for the paging component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the parent table.\n\t\t * @fires FooTable.Paging#\"preinit.ft.paging\"\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.paging event is raised before the UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Paging#\"preinit.ft.paging\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\tthis.ft.raise('preinit.ft.paging', [data]).then(function(){\n\t\t\t\tif (self.ft.$el.hasClass('footable-paging'))\n\t\t\t\t\tself.enabled = true;\n\t\t\t\tself.enabled = F.is.boolean(data.paging)\n\t\t\t\t\t? data.paging\n\t\t\t\t\t: self.enabled;\n\n\t\t\t\tif (!self.enabled) return;\n\n\t\t\t\tself.size = F.is.number(data.pagingSize)\n\t\t\t\t\t? data.pagingSize\n\t\t\t\t\t: self.size;\n\n\t\t\t\tself.current = F.is.number(data.pagingCurrent)\n\t\t\t\t\t? data.pagingCurrent\n\t\t\t\t\t: self.current;\n\n\t\t\t\tself.limit = F.is.number(data.pagingLimit)\n\t\t\t\t\t? data.pagingLimit\n\t\t\t\t\t: self.limit;\n\n\t\t\t\tif (self.ft.$el.hasClass('footable-paging-left'))\n\t\t\t\t\tself.position = 'left';\n\t\t\t\tif (self.ft.$el.hasClass('footable-paging-center'))\n\t\t\t\t\tself.position = 'center';\n\t\t\t\tif (self.ft.$el.hasClass('footable-paging-right'))\n\t\t\t\t\tself.position = 'right';\n\n\t\t\t\tself.position = F.is.string(data.pagingPosition)\n\t\t\t\t\t? data.pagingPosition\n\t\t\t\t\t: self.position;\n\n\t\t\t\tself.countFormat = F.is.string(data.pagingCountFormat)\n\t\t\t\t\t? data.pagingCountFormat\n\t\t\t\t\t: self.countFormat;\n\n\t\t\t\tself.container = F.is.string(data.pagingContainer)\n\t\t\t\t\t? data.pagingContainer\n\t\t\t\t\t: self.container;\n\n\t\t\t\tself.total = Math.ceil(self.ft.rows.all.length / self.size);\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the paging component for the plugin using the supplied table and options.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Paging#\"init.ft.paging\"\n\t\t */\n\t\tinit: function(){\n\t\t\t/**\n\t\t\t * The init.ft.paging event is raised before its UI is generated.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Paging#\"init.ft.paging\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('init.ft.paging').then(function(){\n\t\t\t\tself.$create();\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys the paging component removing any UI generated from the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Paging#\"destroy.ft.paging\"\n\t\t */\n\t\tdestroy: function () {\n\t\t\t/**\n\t\t\t * The destroy.ft.paging event is raised before its UI is removed.\n\t\t\t * Calling preventDefault on this event will prevent the component from being destroyed.\n\t\t\t * @event FooTable.Paging#\"destroy.ft.paging\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('destroy.ft.paging').then(function(){\n\t\t\t\tself.ft.$el.removeClass('footable-paging')\n\t\t\t\t\t.find('tfoot > tr.footable-paging').remove();\n\t\t\t\tself.detached = true;\n\t\t\t\tself._createdLinks = 0;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Performs the actual paging against the {@link FooTable.Rows#current} array removing all rows that are not on the current visible page.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tpredraw: function(){\n\t\t\tthis.total = Math.ceil(this.ft.rows.array.length / this.size);\n\t\t\tthis.current = this.current > this.total ? this.total : (this.current < 1 ? 1 : this.current);\n\t\t\tthis.totalRows = this.ft.rows.array.length;\n\t\t\tif (this.totalRows > this.size){\n\t\t\t\tthis.ft.rows.array = this.ft.rows.array.splice((this.current - 1) * this.size, this.size);\n\t\t\t}\n\t\t\tthis.formattedCount = this.format(this.countFormat);\n\t\t},\n\t\t/**\n\t\t * Updates the paging UI setting the state of the pagination control.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\tdraw: function(){\n\t\t\tif (this.total <= 1){\n\t\t\t\tif (!this.detached){\n\t\t\t\t\tif (this.$row){\n\t\t\t\t\t\tthis.$row.detach();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$wrapper.detach();\n\t\t\t\t\t}\n\t\t\t\t\tthis.detached = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.detached){\n\t\t\t\t\tif (this.$row){\n\t\t\t\t\t\tvar $tfoot = this.ft.$el.children('tfoot');\n\t\t\t\t\t\tif ($tfoot.length == 0){\n\t\t\t\t\t\t\t$tfoot = $('<tfoot/>');\n\t\t\t\t\t\t\tthis.ft.$el.append($tfoot);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.$row.appendTo($tfoot);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$wrapper.appendTo(this.$container);\n\t\t\t\t\t}\n\t\t\t\t\tthis.detached = false;\n\t\t\t\t}\n\t\t\t\tif (F.is.jq(this.$cell)){\n\t\t\t\t\tthis.$cell.attr('colspan', this.ft.columns.visibleColspan);\n\t\t\t\t}\n\t\t\t\tthis._createLinks();\n\t\t\t\tthis._setVisible(this.current, this.current > this.previous);\n\t\t\t\tthis._setNavigation(true);\n\t\t\t\tthis.$count.text(this.formattedCount);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Creates the paging UI from the current options setting the various jQuery properties of this component.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\t$create: function(){\n\t\t\tthis._createdLinks = 0;\n\t\t\tvar position = 'footable-paging-center';\n\t\t\tswitch (this.position){\n\t\t\t\tcase 'left': position = 'footable-paging-left'; break;\n\t\t\t\tcase 'right': position = 'footable-paging-right'; break;\n\t\t\t}\n\t\t\tthis.ft.$el.addClass('footable-paging').addClass(position);\n\n\t\t\tthis.$container = this.container === null ? null : $(this.container).first();\n\t\t\tif (!F.is.jq(this.$container)){\n\t\t\t\tvar $tfoot = this.ft.$el.children('tfoot');\n\t\t\t\tif ($tfoot.length == 0){\n\t\t\t\t\t$tfoot = $('<tfoot/>');\n\t\t\t\t\tthis.ft.$el.append($tfoot);\n\t\t\t\t}\n\t\t\t\t// add it to a row and then populate it with the search input and column selector dropdown.\n\t\t\t\tthis.$row = $('<tr/>', {'class': 'footable-paging'}).prependTo($tfoot);\n\t\t\t\tthis.$container = this.$cell = $('<td/>').attr('colspan', this.ft.columns.visibleColspan).appendTo(this.$row);\n\t\t\t} else {\n\t\t\t\tthis.$container.addClass('footable-paging-external').addClass(position);\n\t\t\t}\n\t\t\tthis.$wrapper = $('<div/>', {'class': 'footable-pagination-wrapper'}).appendTo(this.$container);\n\t\t\tthis.$pagination = $('<ul/>', { 'class': 'pagination' }).on('click.footable', 'a.footable-page-link', { self: this }, this._onPageClicked);\n\t\t\tthis.$count = $('<span/>', { 'class': 'label label-default' });\n\t\t\tthis.$wrapper.append(this.$pagination, $('<div/>', {'class': 'divider'}), this.$count);\n\t\t\tthis.detached = false;\n\t\t},\n\n\t\t/* PUBLIC */\n\t\t/**\n\t\t * @summary Uses the supplied format string and replaces the placeholder strings with the current values.\n\t\t * @description This method is used to generate the short description label for the pagination control. i.e. Showing X of Y records. The placeholders for this string are the following:\n\t\t * * {CP} - The current page number.\n\t\t * * {TP} - The total number of pages.\n\t\t * * {PF} - The first row of the current page.\n\t\t * * {PL} - The last row of the current page.\n\t\t * * {TR} - The total rows available.\n\t\t * These placeholders can be supplied in a string like; \"Showing {PF} to {PL} of {TR} rows.\"\n\t\t * @param {string} formatString - The string to be formatted with the paging specific variables.\n\t\t * @returns {string}\n\t\t */\n\t\tformat: function(formatString){\n\t\t\tvar firstRow = (this.size * (this.current - 1)) + 1,\n\t\t\t\tlastRow = this.size * this.current;\n\t\t\tif (this.ft.rows.array.length == 0){\n\t\t\t\tfirstRow = 0;\n\t\t\t\tlastRow = 0;\n\t\t\t} else {\n\t\t\t\tlastRow = lastRow > this.totalRows ? this.totalRows : lastRow;\n\t\t\t}\n\t\t\treturn formatString.replace(/\\{CP}/g, this.current)\n\t\t\t\t.replace(/\\{TP}/g, this.total)\n\t\t\t\t.replace(/\\{PF}/g, firstRow)\n\t\t\t\t.replace(/\\{PL}/g, lastRow)\n\t\t\t\t.replace(/\\{TR}/g, this.totalRows);\n\t\t},\n\t\t/**\n\t\t * Pages to the first page.\n\t\t * @instance\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Paging#\"before.ft.paging\"\n\t\t * @fires FooTable.Paging#\"after.ft.paging\"\n\t\t */\n\t\tfirst: function(){\n\t\t\treturn this._set(1);\n\t\t},\n\t\t/**\n\t\t * Pages to the previous page.\n\t\t * @instance\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Paging#\"before.ft.paging\"\n\t\t * @fires FooTable.Paging#\"after.ft.paging\"\n\t\t */\n\t\tprev: function(){\n\t\t\treturn this._set(this.current - 1 > 0 ? this.current - 1 : 1);\n\t\t},\n\t\t/**\n\t\t * Pages to the next page.\n\t\t * @instance\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Paging#\"before.ft.paging\"\n\t\t * @fires FooTable.Paging#\"after.ft.paging\"\n\t\t */\n\t\tnext: function(){\n\t\t\treturn this._set(this.current + 1 < this.total ? this.current + 1 : this.total);\n\t\t},\n\t\t/**\n\t\t * Pages to the last page.\n\t\t * @instance\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Paging#\"before.ft.paging\"\n\t\t * @fires FooTable.Paging#\"after.ft.paging\"\n\t\t */\n\t\tlast: function(){\n\t\t\treturn this._set(this.total);\n\t\t},\n\t\t/**\n\t\t * Pages to the specified page.\n\t\t * @instance\n\t\t * @param {number} page - The page number to go to.\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Paging#\"before.ft.paging\"\n\t\t * @fires FooTable.Paging#\"after.ft.paging\"\n\t\t */\n\t\tgoto: function(page){\n\t\t\treturn this._set(page > this.total ? this.total : (page < 1 ? 1 : page));\n\t\t},\n\t\t/**\n\t\t * Shows the previous X number of pages in the pagination control where X is the value set by the {@link FooTable.Defaults#paging} - limit option value.\n\t\t * @instance\n\t\t */\n\t\tprevPages: function(){\n\t\t\tvar page = this.$pagination.children('li.footable-page.visible:first').data('page') - 1;\n\t\t\tthis._setVisible(page, true);\n\t\t\tthis._setNavigation(false);\n\t\t},\n\t\t/**\n\t\t * Shows the next X number of pages in the pagination control where X is the value set by the {@link FooTable.Defaults#paging} - limit option value.\n\t\t * @instance\n\t\t */\n\t\tnextPages: function(){\n\t\t\tvar page = this.$pagination.children('li.footable-page.visible:last').data('page') + 1;\n\t\t\tthis._setVisible(page, false);\n\t\t\tthis._setNavigation(false);\n\t\t},\n\t\t/**\n\t\t * Gets or sets the current page size.\n\t\t * @instance\n\t\t * @param {(number|string)} [value] - The new page size to use, this value is supplied to `parseInt` so strings can be used. If not supplied or an invalid valid the current page size is returned.\n\t\t * @returns {(number|undefined)}\n\t\t */\n\t\tpageSize: function(value){\n\t\t\tvalue = parseInt(value);\n\t\t\tif (isNaN(value)){\n\t\t\t\treturn this.size;\n\t\t\t}\n\t\t\tthis.size = value;\n\t\t\tthis.total = Math.ceil(this.ft.rows.all.length / this.size);\n\t\t\tif (F.is.jq(this.$wrapper)){\n\t\t\t\tif (this.$container.is(\"td\")){\n\t\t\t\t\tthis.$row.remove();\n\t\t\t\t} else {\n\t\t\t\t\tthis.$wrapper.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.$create();\n\t\t\tthis.ft.draw();\n\t\t},\n\n\t\t/* PRIVATE */\n\t\t/**\n\t\t * Performs the required steps to handle paging including the raising of the {@link FooTable.Paging#\"before.ft.paging\"} and {@link FooTable.Paging#\"after.ft.paging\"} events.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {number} page - The page to set.\n\t\t * @returns {jQuery.Promise}\n\t\t * @fires FooTable.Paging#\"before.ft.paging\"\n\t\t * @fires FooTable.Paging#\"after.ft.paging\"\n\t\t */\n\t\t_set: function(page){\n\t\t\tvar self = this,\n\t\t\t\tpager = new F.Pager(self.total, self.current, self.size, page, page > self.current);\n\t\t\t/**\n\t\t\t * The before.ft.paging event is raised before a sort is applied and allows listeners to modify the pager or cancel it completely by calling preventDefault on the jQuery.Event object.\n\t\t\t * @event FooTable.Paging#\"before.ft.paging\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {FooTable.Pager} pager - The pager that is about to be applied.\n\t\t\t */\n\t\t\treturn self.ft.raise('before.ft.paging', [pager]).then(function(){\n\t\t\t\tpager.page = pager.page > pager.total ? pager.total\t: pager.page;\n\t\t\t\tpager.page = pager.page < 1 ? 1 : pager.page;\n\t\t\t\tif (self.current == page) return $.when();\n\t\t\t\tself.previous = self.current;\n\t\t\t\tself.current = pager.page;\n\t\t\t\treturn self.ft.draw().then(function(){\n\t\t\t\t\t/**\n\t\t\t\t\t * The after.ft.paging event is raised after a pager has been applied.\n\t\t\t\t\t * @event FooTable.Paging#\"after.ft.paging\"\n\t\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t\t * @param {FooTable.Pager} pager - The pager that has been applied.\n\t\t\t\t\t */\n\t\t\t\t\tself.ft.raise('after.ft.paging', [pager]);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Creates the pagination links using the current state of the plugin. If the total number of pages is the same as\n\t\t * the last time this function was executed it does nothing.\n\t\t * @instance\n\t\t * @private\n\t\t */\n\t\t_createLinks: function(){\n\t\t\tif (this._createdLinks === this.total) return;\n\t\t\tvar self = this,\n\t\t\t\tmultiple = self.total > 1,\n\t\t\t\tlink = function(attr, html, klass){\n\t\t\t\t\treturn $('<li/>', {\n\t\t\t\t\t\t'class': klass\n\t\t\t\t\t}).attr('data-page', attr)\n\t\t\t\t\t\t.append($('<a/>', {\n\t\t\t\t\t\t\t'class': 'footable-page-link',\n\t\t\t\t\t\t\thref: '#'\n\t\t\t\t\t\t}).data('page', attr).html(html));\n\t\t\t\t};\n\t\t\tself.$pagination.empty();\n\t\t\tif (multiple) {\n\t\t\t\tself.$pagination.append(link('first', self.strings.first, 'footable-page-nav'));\n\t\t\t\tself.$pagination.append(link('prev', self.strings.prev, 'footable-page-nav'));\n\t\t\t\tif (self.limit > 0 && self.limit < self.total){\n\t\t\t\t\tself.$pagination.append(link('prev-limit', self.strings.prevPages, 'footable-page-nav'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i = 0, $li; i < self.total; i++){\n\t\t\t\t$li = link(i + 1, i + 1, 'footable-page');\n\t\t\t\tself.$pagination.append($li);\n\t\t\t}\n\t\t\tif (multiple){\n\t\t\t\tif (self.limit > 0 && self.limit < self.total){\n\t\t\t\t\tself.$pagination.append(link('next-limit', self.strings.nextPages, 'footable-page-nav'));\n\t\t\t\t}\n\t\t\t\tself.$pagination.append(link('next', self.strings.next, 'footable-page-nav'));\n\t\t\t\tself.$pagination.append(link('last', self.strings.last, 'footable-page-nav'));\n\t\t\t}\n\t\t\tself._createdLinks = self.total;\n\t\t},\n\t\t/**\n\t\t * Sets the state for the navigation links of the pagination control and optionally sets the active class state on the current page link.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {boolean} active - Whether or not to set the active class state on the individual page links.\n\t\t */\n\t\t_setNavigation: function(active){\n\t\t\tif (this.current == 1) {\n\t\t\t\tthis.$pagination.children('li[data-page=\"first\"],li[data-page=\"prev\"]').addClass('disabled');\n\t\t\t} else {\n\t\t\t\tthis.$pagination.children('li[data-page=\"first\"],li[data-page=\"prev\"]').removeClass('disabled');\n\t\t\t}\n\n\t\t\tif (this.current == this.total) {\n\t\t\t\tthis.$pagination.children('li[data-page=\"next\"],li[data-page=\"last\"]').addClass('disabled');\n\t\t\t} else {\n\t\t\t\tthis.$pagination.children('li[data-page=\"next\"],li[data-page=\"last\"]').removeClass('disabled');\n\t\t\t}\n\n\t\t\tif ((this.$pagination.children('li.footable-page.visible:first').data('page') || 1) == 1) {\n\t\t\t\tthis.$pagination.children('li[data-page=\"prev-limit\"]').addClass('disabled');\n\t\t\t} else {\n\t\t\t\tthis.$pagination.children('li[data-page=\"prev-limit\"]').removeClass('disabled');\n\t\t\t}\n\n\t\t\tif ((this.$pagination.children('li.footable-page.visible:last').data('page') || this.limit) == this.total) {\n\t\t\t\tthis.$pagination.children('li[data-page=\"next-limit\"]').addClass('disabled');\n\t\t\t} else {\n\t\t\t\tthis.$pagination.children('li[data-page=\"next-limit\"]').removeClass('disabled');\n\t\t\t}\n\n\t\t\tif (this.limit > 0 && this.total < this.limit){\n\t\t\t\tthis.$pagination.children('li[data-page=\"prev-limit\"],li[data-page=\"next-limit\"]').css('display', 'none');\n\t\t\t} else {\n\t\t\t\tthis.$pagination.children('li[data-page=\"prev-limit\"],li[data-page=\"next-limit\"]').css('display', '');\n\t\t\t}\n\n\t\t\tif (active){\n\t\t\t\tthis.$pagination.children('li.footable-page').removeClass('active').filter('li[data-page=\"' + this.current + '\"]').addClass('active');\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Sets the visible page using the supplied parameters.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {number} page - The page to make visible.\n\t\t * @param {boolean} right - If set to true the supplied page will be the right most visible pagination link.\n\t\t */\n\t\t_setVisible: function(page, right){\n\t\t\tif (this.limit > 0 && this.total > this.limit){\n\t\t\t\tif (!this.$pagination.children('li.footable-page[data-page=\"'+page+'\"]').hasClass('visible')){\n\t\t\t\t\tvar start = 0, end = 0;\n\t\t\t\t\tif (right == true){\n\t\t\t\t\t\tend = page > this.total ? this.total : page;\n\t\t\t\t\t\tstart = end - this.limit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart = page < 1 ? 0 : page - 1;\n\t\t\t\t\t\tend = start + this.limit;\n\t\t\t\t\t}\n\t\t\t\t\tif (start < 0){\n\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\tend = this.limit > this.total ? this.total : this.limit;\n\t\t\t\t\t}\n\t\t\t\t\tif (end > this.total){\n\t\t\t\t\t\tend = this.total;\n\t\t\t\t\t\tstart = this.total - this.limit < 0 ? 0 : this.total - this.limit;\n\t\t\t\t\t}\n\t\t\t\t\tthis.$pagination.children('li.footable-page').removeClass('visible').slice(start, end).addClass('visible');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.$pagination.children('li.footable-page').removeClass('visible').slice(0, this.total).addClass('visible');\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the click event for all links in the pagination control.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The event object for the event.\n\t\t */\n\t\t_onPageClicked: function(e){\n\t\t\te.preventDefault();\n\t\t\tif ($(e.target).closest('li').is('.active,.disabled')) return;\n\n\t\t\tvar self = e.data.self, page = $(this).data('page');\n\t\t\tswitch(page){\n\t\t\t\tcase 'first': self.first();\n\t\t\t\t\treturn;\n\t\t\t\tcase 'prev': self.prev();\n\t\t\t\t\treturn;\n\t\t\t\tcase 'next': self.next();\n\t\t\t\t\treturn;\n\t\t\t\tcase 'last': self.last();\n\t\t\t\t\treturn;\n\t\t\t\tcase 'prev-limit': self.prevPages();\n\t\t\t\t\treturn;\n\t\t\t\tcase 'next-limit': self.nextPages();\n\t\t\t\t\treturn;\n\t\t\t\tdefault: self._set(page);\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n\n\tF.components.register('paging', F.Paging, 400);\n\n})(jQuery, FooTable);\n(function(F){\n\t/**\n\t * An object containing the paging options for the plugin. Added by the {@link FooTable.Paging} component.\n\t * @type {object}\n\t * @prop {boolean} enabled=false - Whether or not to allow paging on the table.\n\t * @prop {string} countFormat=\"{CP} of {TP}\" - A string format used to generate the page count text.\n\t * @prop {number} current=1 - The page number to display.\n\t * @prop {number} limit=5 - The maximum number of page links to display at once.\n\t * @prop {string} position=\"center\" - The string used to specify the alignment of the pagination control.\n\t * @prop {number} size=10 - The number of rows displayed per page.\n\t * @prop {string} container=null - A selector specifying where to place the paging components UI, if null the UI is displayed within a row in the foot of the table.\n\t * @prop {object} strings - An object containing the strings used by the paging buttons.\n\t * @prop {string} strings.first=\"&laquo;\" - The string used for the 'first' button.\n\t * @prop {string} strings.prev=\"&lsaquo;\" - The string used for the 'previous' button.\n\t * @prop {string} strings.next=\"&rsaquo;\" - The string used for the 'next' button.\n\t * @prop {string} strings.last=\"&raquo;\" - The string used for the 'last' button.\n\t * @prop {string} strings.prevPages=\"...\" - The string used for the 'previous X pages' button.\n\t * @prop {string} strings.nextPages=\"...\" - The string used for the 'next X pages' button.\n\t */\n\tF.Defaults.prototype.paging = {\n\t\tenabled: false,\n\t\tcountFormat: '{CP} of {TP}',\n\t\tcurrent: 1,\n\t\tlimit: 5,\n\t\tposition: 'center',\n\t\tsize: 10,\n\t\tcontainer: null,\n\t\tstrings: {\n\t\t\tfirst: '&laquo;',\n\t\t\tprev: '&lsaquo;',\n\t\t\tnext: '&rsaquo;',\n\t\t\tlast: '&raquo;',\n\t\t\tprevPages: '...',\n\t\t\tnextPages: '...'\n\t\t}\n\t};\n})(FooTable);\n(function(F){\n\t/**\n\t * Navigates to the specified page number. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @param {number} num - The page number to go to.\n\t * @returns {jQuery.Promise}\n\t * @fires FooTable.Paging#paging_changing\n\t * @fires FooTable.Paging#paging_changed\n\t * @see FooTable.Paging#goto\n\t */\n\tF.Table.prototype.gotoPage = function(num){\n\t\treturn this.use(F.Paging).goto(num);\n\t};\n\n\t/**\n\t * Navigates to the next page. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @returns {jQuery.Promise}\n\t * @fires FooTable.Paging#paging_changing\n\t * @fires FooTable.Paging#paging_changed\n\t * @see FooTable.Paging#next\n\t */\n\tF.Table.prototype.nextPage = function(){\n\t\treturn this.use(F.Paging).next();\n\t};\n\n\t/**\n\t * Navigates to the previous page. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @returns {jQuery.Promise}\n\t * @fires FooTable.Paging#paging_changing\n\t * @fires FooTable.Paging#paging_changed\n\t * @see FooTable.Paging#prev\n\t */\n\tF.Table.prototype.prevPage = function(){\n\t\treturn this.use(F.Paging).prev();\n\t};\n\n\t/**\n\t * Navigates to the first page. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @returns {jQuery.Promise}\n\t * @fires FooTable.Paging#paging_changing\n\t * @fires FooTable.Paging#paging_changed\n\t * @see FooTable.Paging#first\n\t */\n\tF.Table.prototype.firstPage = function(){\n\t\treturn this.use(F.Paging).first();\n\t};\n\n\t/**\n\t * Navigates to the last page. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @returns {jQuery.Promise}\n\t * @fires FooTable.Paging#paging_changing\n\t * @fires FooTable.Paging#paging_changed\n\t * @see FooTable.Paging#last\n\t */\n\tF.Table.prototype.lastPage = function(){\n\t\treturn this.use(F.Paging).last();\n\t};\n\n\t/**\n\t * Shows the next X number of pages in the pagination control where X is the value set by the {@link FooTable.Defaults#paging} - limit.size option value. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @see FooTable.Paging#nextPages\n\t */\n\tF.Table.prototype.nextPages = function(){\n\t\treturn this.use(F.Paging).nextPages();\n\t};\n\n\t/**\n\t * Shows the previous X number of pages in the pagination control where X is the value set by the {@link FooTable.Defaults#paging} - limit.size option value. Added by the {@link FooTable.Paging} component.\n\t * @instance\n\t * @see FooTable.Paging#prevPages\n\t */\n\tF.Table.prototype.prevPages = function(){\n\t\treturn this.use(F.Paging).prevPages();\n\t};\n\n\t/**\n\t * Gets or sets the current page size\n\t * @instance\n\t * @param {number} [value] - The new page size to use.\n\t * @returns {(number|undefined)}\n\t * @see FooTable.Paging#pageSize\n\t */\n\tF.Table.prototype.pageSize = function(value){\n\t\treturn this.use(F.Paging).pageSize(value);\n\t};\n})(FooTable);\n(function($, F){\n\n\tF.Editing = F.Component.extend(/** @lends FooTable.Editing */{\n\t\t/**\n\t\t * The editing component adds a column with edit and delete buttons to each row as well as a single add row button in the footer.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table - The parent {@link FooTable.Table} object for the component.\n\t\t * @returns {FooTable.Editing}\n\t\t */\n\t\tconstruct: function(table){\n\t\t\t// call the base constructor\n\t\t\tthis._super(table, table.o.editing.enabled);\n\n\t\t\t/**\n\t\t\t * Whether or not to automatically page to a new row when it is added to the table.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.pageToNew = table.o.editing.pageToNew;\n\n\t\t\t/**\n\t\t\t * Whether or not the editing column and add row button are always visible.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.alwaysShow = table.o.editing.alwaysShow;\n\n\t\t\t/**\n\t\t\t * The options for the editing column. @see {@link FooTable.EditingColumn} for more info.\n\t\t\t * @type {object}\n\t\t\t * @prop {string} classes=\"footable-editing\" - A space separated string of class names to apply to all cells in the column.\n\t\t\t * @prop {string} name=\"editing\" - The name of the column.\n\t\t\t * @prop {string} title=\"\" - The title displayed in the header row of the table for the column.\n\t\t\t * @prop {boolean} filterable=false - Whether or not the column should be filterable when using the filtering component.\n\t\t\t * @prop {boolean} sortable=false - Whether or not the column should be sortable when using the sorting component.\n\t\t\t */\n\t\t\tthis.column = $.extend(true, {}, table.o.editing.column, {visible: this.alwaysShow});\n\n\t\t\t/**\n\t\t\t * The position of the editing column in the table as well as the alignment of the buttons.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.position = table.o.editing.position;\n\n\n\t\t\t/**\n\t\t\t * The text that appears in the show button. This can contain HTML.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.showText = table.o.editing.showText;\n\n\t\t\t/**\n\t\t\t * The text that appears in the hide button. This can contain HTML.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.hideText = table.o.editing.hideText;\n\n\t\t\t/**\n\t\t\t * The text that appears in the add button. This can contain HTML.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.addText = table.o.editing.addText;\n\n\t\t\t/**\n\t\t\t * The text that appears in the edit button. This can contain HTML.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.editText = table.o.editing.editText;\n\n\t\t\t/**\n\t\t\t * The text that appears in the delete button. This can contain HTML.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.deleteText = table.o.editing.deleteText;\n\n\t\t\t/**\n\t\t\t * The text that appears in the view button. This can contain HTML.\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.viewText = table.o.editing.viewText;\n\n\t\t\t/**\n\t\t\t * Whether or not to show the Add Row button.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.allowAdd = table.o.editing.allowAdd;\n\n\t\t\t/**\n\t\t\t * Whether or not to show the Edit Row button.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.allowEdit = table.o.editing.allowEdit;\n\n\t\t\t/**\n\t\t\t * Whether or not to show the Delete Row button.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.allowDelete = table.o.editing.allowDelete;\n\n\t\t\t/**\n\t\t\t * Whether or not to show the View Row button.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.allowView = table.o.editing.allowView;\n\n\t\t\t/**\n\t\t\t * Caches the row button elements to help with performance.\n\t\t\t * @type {(null|jQuery)}\n\t\t\t * @private\n\t\t\t */\n\t\t\tthis._$buttons = null;\n\n\t\t\t/**\n\t\t\t * This object is used to contain the callbacks for the add, edit and delete row buttons.\n\t\t\t * @type {object}\n\t\t\t * @prop {function} addRow\n\t\t\t * @prop {function} editRow\n\t\t\t * @prop {function} deleteRow\n\t\t\t * @prop {function} viewRow\n\t\t\t */\n\t\t\tthis.callbacks = {\n\t\t\t\taddRow: F.checkFnValue(this, table.o.editing.addRow),\n\t\t\t\teditRow: F.checkFnValue(this, table.o.editing.editRow),\n\t\t\t\tdeleteRow: F.checkFnValue(this, table.o.editing.deleteRow),\n\t\t\t\tviewRow: F.checkFnValue(this, table.o.editing.viewRow)\n\t\t\t};\n\t\t},\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * Checks the supplied data and options for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the parent table.\n\t\t * @fires FooTable.Editing#\"preinit.ft.editing\"\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.editing event is raised before the UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Editing#\"preinit.ft.editing\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\tthis.ft.raise('preinit.ft.editing', [data]).then(function(){\n\t\t\t\tif (self.ft.$el.hasClass('footable-editing'))\n\t\t\t\t\tself.enabled = true;\n\n\t\t\t\tself.enabled = F.is.boolean(data.editing)\n\t\t\t\t\t? data.editing\n\t\t\t\t\t: self.enabled;\n\n\t\t\t\tif (!self.enabled) return;\n\n\t\t\t\tself.pageToNew = F.is.boolean(data.editingPageToNew) ? data.editingPageToNew : self.pageToNew;\n\n\t\t\t\tself.alwaysShow = F.is.boolean(data.editingAlwaysShow) ? data.editingAlwaysShow : self.alwaysShow;\n\n\t\t\t\tself.position = F.is.string(data.editingPosition) ? data.editingPosition : self.position;\n\n\t\t\t\tself.showText = F.is.string(data.editingShowText) ? data.editingShowText : self.showText;\n\n\t\t\t\tself.hideText = F.is.string(data.editingHideText) ? data.editingHideText : self.hideText;\n\n\t\t\t\tself.addText = F.is.string(data.editingAddText) ? data.editingAddText : self.addText;\n\n\t\t\t\tself.editText = F.is.string(data.editingEditText) ? data.editingEditText : self.editText;\n\n\t\t\t\tself.deleteText = F.is.string(data.editingDeleteText) ? data.editingDeleteText : self.deleteText;\n\n\t\t\t\tself.viewText = F.is.string(data.editingViewText) ? data.editingViewText : self.viewText;\n\n\t\t\t\tself.allowAdd = F.is.boolean(data.editingAllowAdd) ? data.editingAllowAdd : self.allowAdd;\n\n\t\t\t\tself.allowEdit = F.is.boolean(data.editingAllowEdit) ? data.editingAllowEdit : self.allowEdit;\n\n\t\t\t\tself.allowDelete = F.is.boolean(data.editingAllowDelete) ? data.editingAllowDelete : self.allowDelete;\n\n\t\t\t\tself.allowView = F.is.boolean(data.editingAllowView) ? data.editingAllowView : self.allowView;\n\n\t\t\t\tself.column = new F.EditingColumn(self.ft, self, $.extend(true, {}, self.column, data.editingColumn, {visible: self.alwaysShow}));\n\n\t\t\t\tif (self.ft.$el.hasClass('footable-editing-left'))\n\t\t\t\t\tself.position = 'left';\n\n\t\t\t\tif (self.ft.$el.hasClass('footable-editing-right'))\n\t\t\t\t\tself.position = 'right';\n\n\t\t\t\tif (self.position === 'right'){\n\t\t\t\t\tself.column.index = self.ft.columns.array.length;\n\t\t\t\t} else {\n\t\t\t\t\tself.column.index = 0;\n\t\t\t\t\tfor (var i = 0, len = self.ft.columns.array.length; i < len; i++){\n\t\t\t\t\t\tself.ft.columns.array[i].index += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself.ft.columns.array.push(self.column);\n\t\t\t\tself.ft.columns.array.sort(function(a, b){ return a.index - b.index; });\n\n\t\t\t\tself.callbacks.addRow = F.checkFnValue(self, data.editingAddRow, self.callbacks.addRow);\n\t\t\t\tself.callbacks.editRow = F.checkFnValue(self, data.editingEditRow, self.callbacks.editRow);\n\t\t\t\tself.callbacks.deleteRow = F.checkFnValue(self, data.editingDeleteRow, self.callbacks.deleteRow);\n\t\t\t\tself.callbacks.viewRow = F.checkFnValue(self, data.editingViewRow, self.callbacks.viewRow);\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Initializes the editing component for the plugin using the supplied table and options.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Editing#\"init.ft.editing\"\n\t\t */\n\t\tinit: function(){\n\t\t\t/**\n\t\t\t * The init.ft.editing event is raised before its UI is generated.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.Editing#\"init.ft.editing\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('init.ft.editing').then(function(){\n\t\t\t\tself.$create();\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Destroys the editing component removing any UI generated from the table.\n\t\t * @instance\n\t\t * @protected\n\t\t * @fires FooTable.Editing#\"destroy.ft.editing\"\n\t\t */\n\t\tdestroy: function () {\n\t\t\t/**\n\t\t\t * The destroy.ft.editing event is raised before its UI is removed.\n\t\t\t * Calling preventDefault on this event will prevent the component from being destroyed.\n\t\t\t * @event FooTable.Editing#\"destroy.ft.editing\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tvar self = this;\n\t\t\tthis.ft.raise('destroy.ft.editing').then(function(){\n\t\t\t\tself.ft.$el.removeClass('footable-editing footable-editing-always-show footable-editing-no-add footable-editing-no-edit footable-editing-no-delete footable-editing-no-view')\n\t\t\t\t\t.off('click.ft.editing').find('tfoot > tr.footable-editing').remove();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Creates the editing UI from the current options setting the various jQuery properties of this component.\n\t\t * @instance\n\t\t * @protected\n\t\t */\n\t\t$create: function(){\n\t\t\tvar self = this, position = self.position === 'right' ? 'footable-editing-right' : 'footable-editing-left';\n\t\t\tself.ft.$el.addClass('footable-editing').addClass(position)\n\t\t\t\t.on('click.ft.editing', '.footable-show', {self: self}, self._onShowClick)\n\t\t\t\t.on('click.ft.editing', '.footable-hide', {self: self}, self._onHideClick)\n\t\t\t\t.on('click.ft.editing', '.footable-edit', {self: self}, self._onEditClick)\n\t\t\t\t.on('click.ft.editing', '.footable-delete', {self: self}, self._onDeleteClick)\n\t\t\t\t.on('click.ft.editing', '.footable-view', {self: self}, self._onViewClick)\n\t\t\t\t.on('click.ft.editing', '.footable-add', {self: self}, self._onAddClick);\n\n\t\t\tself.$cell = $('<td/>').attr('colspan', self.ft.columns.visibleColspan).append(self.$buttonShow());\n\t\t\tif (self.allowAdd){\n\t\t\t\tself.$cell.append(self.$buttonAdd());\n\t\t\t}\n\t\t\tself.$cell.append(self.$buttonHide());\n\n\t\t\tif (self.alwaysShow){\n\t\t\t\tself.ft.$el.addClass('footable-editing-always-show');\n\t\t\t}\n\n\t\t\tif (!self.allowAdd) self.ft.$el.addClass('footable-editing-no-add');\n\t\t\tif (!self.allowEdit) self.ft.$el.addClass('footable-editing-no-edit');\n\t\t\tif (!self.allowDelete) self.ft.$el.addClass('footable-editing-no-delete');\n\t\t\tif (!self.allowView) self.ft.$el.addClass('footable-editing-no-view');\n\n\t\t\tvar $tfoot = self.ft.$el.children('tfoot');\n\t\t\tif ($tfoot.length == 0){\n\t\t\t\t$tfoot = $('<tfoot/>');\n\t\t\t\tself.ft.$el.append($tfoot);\n\t\t\t}\n\t\t\tself.$row = $('<tr/>', { 'class': 'footable-editing' }).append(self.$cell).appendTo($tfoot);\n\t\t},\n\t\t/**\n\t\t * Creates the show button for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$buttonShow: function(){\n\t\t\treturn '<button type=\"button\" class=\"btn btn-primary footable-show\">' + this.showText + '</button>';\n\t\t},\n\t\t/**\n\t\t * Creates the hide button for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$buttonHide: function(){\n\t\t\treturn '<button type=\"button\" class=\"btn btn-default footable-hide\">' + this.hideText + '</button>';\n\t\t},\n\t\t/**\n\t\t * Creates the add button for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$buttonAdd: function(){\n\t\t\treturn '<button type=\"button\" class=\"btn btn-primary footable-add\">' + this.addText + '</button> ';\n\t\t},\n\t\t/**\n\t\t * Creates the edit button for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$buttonEdit: function(){\n\t\t\treturn '<button type=\"button\" class=\"btn btn-default footable-edit\">' + this.editText + '</button> ';\n\t\t},\n\t\t/**\n\t\t * Creates the delete button for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$buttonDelete: function(){\n\t\t\treturn '<button type=\"button\" class=\"btn btn-default footable-delete\">' + this.deleteText + '</button>';\n\t\t},\n\t\t/**\n\t\t * Creates the view button for the editing component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$buttonView: function(){\n\t\t\treturn '<button type=\"button\" class=\"btn btn-default footable-view\">' + this.viewText + '</button> ';\n\t\t},\n\t\t/**\n\t\t * Creates the button group for the row buttons.\n\t\t * @instance\n\t\t * @protected\n\t\t * @returns {(string|HTMLElement|jQuery)}\n\t\t */\n\t\t$rowButtons: function(){\n\t\t\tif (F.is.jq(this._$buttons)) return this._$buttons.clone();\n\t\t\tthis._$buttons = $('<div class=\"btn-group btn-group-xs\" role=\"group\"></div>');\n\t\t\tif (this.allowView) this._$buttons.append(this.$buttonView());\n\t\t\tif (this.allowEdit) this._$buttons.append(this.$buttonEdit());\n\t\t\tif (this.allowDelete) this._$buttons.append(this.$buttonDelete());\n\t\t\treturn this._$buttons;\n\t\t},\n\t\t/**\n\t\t * Performs the drawing of the component.\n\t\t */\n\t\tdraw: function(){\n\t\t\tthis.$cell.attr('colspan', this.ft.columns.visibleColspan);\n\t\t},\n\t\t/**\n\t\t * Handles the edit button click event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t * @fires FooTable.Editing#\"edit.ft.editing\"\n\t\t */\n\t\t_onEditClick: function(e){\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self, row = $(this).closest('tr').data('__FooTableRow__');\n\t\t\tif (row instanceof F.Row){\n\t\t\t\t/**\n\t\t\t\t * The edit.ft.editing event is raised before its callback is executed.\n\t\t\t\t * Calling preventDefault on this event will prevent the callback from being executed.\n\t\t\t\t * @event FooTable.Editing#\"edit.ft.editing\"\n\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t * @param {FooTable.Row} row - The row to be edited.\n\t\t\t\t */\n\t\t\t\tself.ft.raise('edit.ft.editing', [row]).then(function(){\n\t\t\t\t\tself.callbacks.editRow.call(self.ft, row);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the delete button click event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t * @fires FooTable.Editing#\"delete.ft.editing\"\n\t\t */\n\t\t_onDeleteClick: function(e){\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self, row = $(this).closest('tr').data('__FooTableRow__');\n\t\t\tif (row instanceof F.Row){\n\t\t\t\t/**\n\t\t\t\t * The delete.ft.editing event is raised before its callback is executed.\n\t\t\t\t * Calling preventDefault on this event will prevent the callback from being executed.\n\t\t\t\t * @event FooTable.Editing#\"delete.ft.editing\"\n\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t * @param {FooTable.Row} row - The row to be deleted.\n\t\t\t\t */\n\t\t\t\tself.ft.raise('delete.ft.editing', [row]).then(function(){\n\t\t\t\t\tself.callbacks.deleteRow.call(self.ft, row);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the view button click event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t * @fires FooTable.Editing#\"view.ft.editing\"\n\t\t */\n\t\t_onViewClick: function(e){\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self, row = $(this).closest('tr').data('__FooTableRow__');\n\t\t\tif (row instanceof F.Row){\n\t\t\t\t/**\n\t\t\t\t * The view.ft.editing event is raised before its callback is executed.\n\t\t\t\t * Calling preventDefault on this event will prevent the callback from being executed.\n\t\t\t\t * @event FooTable.Editing#\"view.ft.editing\"\n\t\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t\t * @param {FooTable.Row} row - The row to be viewed.\n\t\t\t\t */\n\t\t\t\tself.ft.raise('view.ft.editing', [row]).then(function(){\n\t\t\t\t\tself.callbacks.viewRow.call(self.ft, row);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Handles the add button click event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t * @fires FooTable.Editing#\"add.ft.editing\"\n\t\t */\n\t\t_onAddClick: function(e){\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self;\n\t\t\t/**\n\t\t\t * The add.ft.editing event is raised before its callback is executed.\n\t\t\t * Calling preventDefault on this event will prevent the callback from being executed.\n\t\t\t * @event FooTable.Editing#\"add.ft.editing\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tself.ft.raise('add.ft.editing').then(function(){\n\t\t\t\tself.callbacks.addRow.call(self.ft);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Handles the show button click event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t * @fires FooTable.Editing#\"show.ft.editing\"\n\t\t */\n\t\t_onShowClick: function(e){\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self;\n\t\t\t/**\n\t\t\t * The show.ft.editing event is raised before its callback is executed.\n\t\t\t * Calling preventDefault on this event will prevent the callback from being executed.\n\t\t\t * @event FooTable.Editing#\"show.ft.editing\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tself.ft.raise('show.ft.editing').then(function(){\n\t\t\t\tself.ft.$el.addClass('footable-editing-show');\n\t\t\t\tself.column.visible = true;\n\t\t\t\tself.ft.draw();\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Handles the hide button click event.\n\t\t * @instance\n\t\t * @private\n\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t * @fires FooTable.Editing#\"show.ft.editing\"\n\t\t */\n\t\t_onHideClick: function(e){\n\t\t\te.preventDefault();\n\t\t\tvar self = e.data.self;\n\t\t\t/**\n\t\t\t * The hide.ft.editing event is raised before its callback is executed.\n\t\t\t * Calling preventDefault on this event will prevent the callback from being executed.\n\t\t\t * @event FooTable.Editing#\"hide.ft.editing\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t */\n\t\t\tself.ft.raise('hide.ft.editing').then(function(){\n\t\t\t\tself.ft.$el.removeClass('footable-editing-show');\n\t\t\t\tself.column.visible = false;\n\t\t\t\tself.ft.draw();\n\t\t\t});\n\t\t}\n\t});\n\n\tF.components.register('editing', F.Editing, 850);\n\n})(jQuery, FooTable);\n\n(function($, F){\n\n\tF.EditingColumn = F.Column.extend(/** @lends FooTable.EditingColumn */{\n\t\t/**\n\t\t * The Editing column class is used to create the column containing the editing buttons.\n\t\t * @constructs\n\t\t * @extends FooTable.Column\n\t\t * @param {FooTable.Table} instance -  The parent {@link FooTable.Table} this column belongs to.\n\t\t * @param {FooTable.Editing} editing - The parent {@link FooTable.Editing} component this column is used with.\n\t\t * @param {object} definition - An object containing all the properties to set for the column.\n\t\t * @returns {FooTable.EditingColumn}\n\t\t */\n\t\tconstruct: function(instance, editing, definition){\n\t\t\tthis._super(instance, definition, 'editing');\n\t\t\tthis.editing = editing;\n\t\t\tthis.internal = true;\n\t\t},\n\t\t/**\n\t\t * After the column has been defined this ensures that the $el property is a jQuery object by either creating or updating the current value.\n\t\t * @instance\n\t\t * @protected\n\t\t * @this FooTable.Column\n\t\t */\n\t\t$create: function(){\n\t\t\t(this.$el = !this.virtual && F.is.jq(this.$el) ? this.$el : $('<th/>', {'class': 'footable-editing'})).html(this.title);\n\t\t},\n\t\t/**\n\t\t * This is supplied either the cell value or jQuery object to parse. Any value can be returned from this method and\n\t\t * will be provided to the {@link FooTable.EditingColumn#format} function\n\t\t * to generate the cell contents.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {(*|jQuery)} valueOrElement - The value or jQuery cell object.\n\t\t * @returns {(jQuery)}\n\t\t */\n\t\tparser: function(valueOrElement){\n\t\t\tif (F.is.string(valueOrElement)) valueOrElement = $($.trim(valueOrElement));\n\t\t\tif (F.is.element(valueOrElement)) valueOrElement = $(valueOrElement);\n\t\t\tif (F.is.jq(valueOrElement)){\n\t\t\t\tvar tagName = valueOrElement.prop('tagName').toLowerCase();\n\t\t\t\tif (tagName == 'td' || tagName == 'th') return valueOrElement.data('value') || valueOrElement.contents();\n\t\t\t\treturn valueOrElement;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Creates a cell to be used in the supplied row for this column.\n\t\t * @param {FooTable.Row} row - The row to create the cell for.\n\t\t * @returns {FooTable.Cell}\n\t\t */\n\t\tcreateCell: function(row){\n\t\t\tvar $buttons = this.editing.$rowButtons(), $cell = $('<td/>').append($buttons);\n\t\t\tif (F.is.jq(row.$el)){\n\t\t\t\tif (this.index === 0){\n\t\t\t\t\t$cell.prependTo(row.$el);\n\t\t\t\t} else {\n\t\t\t\t\t$cell.insertAfter(row.$el.children().eq(this.index-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new F.Cell(this.ft, row, this, $cell || $cell.html());\n\t\t}\n\t});\n\n\tF.columns.register('editing', F.EditingColumn);\n\n})(jQuery, FooTable);\n(function($, F) {\n\n\t/**\n\t * An object containing the editing options for the plugin. Added by the {@link FooTable.Editing} component.\n\t * @type {object}\n\t * @prop {boolean} enabled=false - Whether or not to allow editing on the table.\n\t * @prop {boolean} pageToNew=true - Whether or not to automatically page to a new row when it is added to the table.\n\t * @prop {string} position=\"right\" - The position of the editing column in the table as well as the alignment of the buttons.\n\t * @prop {boolean} alwaysShow=false - Whether or not the editing column and add row button are always visible.\n\t * @prop {function} addRow - The callback function to execute when the add row button is clicked.\n\t * @prop {function} editRow - The callback function to execute when the edit row button is clicked.\n\t * @prop {function} deleteRow - The callback function to execute when the delete row button is clicked.\n\t * @prop {function} viewRow - The callback function to execute when the view row button is clicked.\n\t * @prop {string} showText - The text that appears in the show button. This can contain HTML.\n\t * @prop {string} hideText - The text that appears in the hide button. This can contain HTML.\n\t * @prop {string} addText - The text that appears in the add button. This can contain HTML.\n\t * @prop {string} editText - The text that appears in the edit button. This can contain HTML.\n\t * @prop {string} deleteText - The text that appears in the delete button. This can contain HTML.\n\t * @prop {string} viewText - The text that appears in the view button. This can contain HTML.\n\t * @prop {boolean} allowAdd - Whether or not to show the Add Row button.\n\t * @prop {boolean} allowEdit - Whether or not to show the Edit Row button.\n\t * @prop {boolean} allowDelete - Whether or not to show the Delete Row button.\n\t * @prop {boolean} allowView - Whether or not to show the View Row button.\n\t * @prop {object} column - The options for the editing column. @see {@link FooTable.EditingColumn} for more info.\n\t * @prop {string} column.classes=\"footable-editing\" - A space separated string of class names to apply to all cells in the column.\n\t * @prop {string} column.name=\"editing\" - The name of the column.\n\t * @prop {string} column.title=\"\" - The title displayed in the header row of the table for the column.\n\t * @prop {boolean} column.filterable=false - Whether or not the column should be filterable when using the filtering component.\n\t * @prop {boolean} column.sortable=false - Whether or not the column should be sortable when using the sorting component.\n\t */\n\tF.Defaults.prototype.editing = {\n\t\tenabled: false,\n\t\tpageToNew: true,\n\t\tposition: 'right',\n\t\talwaysShow: false,\n\t\taddRow: function(){},\n\t\teditRow: function(row){},\n\t\tdeleteRow: function(row){},\n\t\tviewRow: function(row){},\n\t\tshowText: '<span class=\"fooicon fooicon-pencil\" aria-hidden=\"true\"></span> Edit rows',\n\t\thideText: 'Cancel',\n\t\taddText: 'New row',\n\t\teditText: '<span class=\"fooicon fooicon-pencil\" aria-hidden=\"true\"></span>',\n\t\tdeleteText: '<span class=\"fooicon fooicon-trash\" aria-hidden=\"true\"></span>',\n\t\tviewText: '<span class=\"fooicon fooicon-stats\" aria-hidden=\"true\"></span>',\n\t\tallowAdd: true,\n\t\tallowEdit: true,\n\t\tallowDelete: true,\n\t\tallowView: false,\n\t\tcolumn: {\n\t\t\tclasses: 'footable-editing',\n\t\t\tname: 'editing',\n\t\t\ttitle: '',\n\t\t\tfilterable: false,\n\t\t\tsortable: false\n\t\t}\n\t};\n\n})(jQuery, FooTable);\n\n(function($, F){\n\n\tif (F.is.defined(F.Paging)){\n\t\t/**\n\t\t * Holds a shallow clone of the un-paged {@link FooTable.Rows#array} value before paging occurs and superfluous rows are removed. Added by the {@link FooTable.Editing} component.\n\t\t * @instance\n\t\t * @public\n\t\t * @type {Array<FooTable.Row>}\n\t\t */\n\t\tF.Paging.prototype.unpaged = [];\n\n\t\t// override the default predraw method with one that sets the unpaged property.\n\t\tF.Paging.extend('predraw', function(){\n\t\t\tthis.unpaged = this.ft.rows.array.slice(0); // create a shallow clone for later use\n\t\t\tthis._super(); // call the original method\n\t\t});\n\t}\n\n})(jQuery, FooTable);\n(function($, F){\n\n\t/**\n\t * Adds the row to the table.\n\t * @param {boolean} [redraw=true] - Whether or not to redraw the table, defaults to true but for bulk operations this\n\t * can be set to false and then followed by a call to the {@link FooTable.Table#draw} method.\n\t * @returns {jQuery.Deferred}\n\t */\n\tF.Row.prototype.add = function(redraw){\n\t\tredraw = F.is.boolean(redraw) ? redraw : true;\n\t\tvar self = this;\n\t\treturn $.Deferred(function(d){\n\t\t\tvar index = self.ft.rows.all.push(self) - 1;\n\t\t\tif (redraw){\n\t\t\t\treturn self.ft.draw().then(function(){\n\t\t\t\t\td.resolve(index);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\td.resolve(index);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Removes the row from the table.\n\t * @param {boolean} [redraw=true] - Whether or not to redraw the table, defaults to true but for bulk operations this\n\t * can be set to false and then followed by a call to the {@link FooTable.Table#draw} method.\n\t * @returns {jQuery.Deferred}\n\t */\n\tF.Row.prototype.delete = function(redraw){\n\t\tredraw = F.is.boolean(redraw) ? redraw : true;\n\t\tvar self = this;\n\t\treturn $.Deferred(function(d){\n\t\t\tvar index = self.ft.rows.all.indexOf(self);\n\t\t\tif (F.is.number(index) && index >= 0 && index < self.ft.rows.all.length){\n\t\t\t\tself.ft.rows.all.splice(index, 1);\n\t\t\t\tif (redraw){\n\t\t\t\t\treturn self.ft.draw().then(function(){\n\t\t\t\t\t\td.resolve(self);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\td.resolve(self);\n\t\t});\n\t};\n\n\tif (F.is.defined(F.Paging)){\n\t\t// override the default add method with one that supports paging\n\t\tF.Row.extend('add', function(redraw){\n\t\t\tredraw = F.is.boolean(redraw) ? redraw : true;\n\t\t\tvar self = this,\n\t\t\t\tadded = this._super(redraw),\n\t\t\t\tediting = self.ft.use(F.Editing),\n\t\t\t\tpaging;\n\t\t\tif (editing && editing.pageToNew && (paging = self.ft.use(F.Paging)) && redraw){\n\t\t\t\treturn added.then(function(){\n\t\t\t\t\tvar index = paging.unpaged.indexOf(self); // find this row in the unpaged array (this array will be sorted and filtered)\n\t\t\t\t\tvar page = Math.ceil((index + 1) / paging.size); // calculate the page the new row is on\n\t\t\t\t\tif (paging.current !== page){ // goto the page if we need to\n\t\t\t\t\t\treturn paging.goto(page);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn added;\n\t\t});\n\t}\n\n\tif (F.is.defined(F.Sorting)){\n\t\t// override the default val method with one that supports sorting and paging\n\t\tF.Row.extend('val', function(data, redraw){\n\t\t\tredraw = F.is.boolean(redraw) ? redraw : true;\n\t\t\tvar result = this._super(data);\n\t\t\tif (!F.is.hash(data)){\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tvar self = this;\n\t\t\tif (redraw){\n\t\t\t\tself.ft.draw().then(function(){\n\t\t\t\t\tvar editing = self.ft.use(F.Editing), paging;\n\t\t\t\t\tif (F.is.defined(F.Paging) && editing && editing.pageToNew && (paging = self.ft.use(F.Paging))){\n\t\t\t\t\t\tvar index = paging.unpaged.indexOf(self); // find this row in the unpaged array (this array will be sorted and filtered)\n\t\t\t\t\t\tvar page = Math.ceil((index + 1) / paging.size); // calculate the page the new row is on\n\t\t\t\t\t\tif (paging.current !== page){ // goto the page if we need to\n\t\t\t\t\t\t\treturn paging.goto(page);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n})(jQuery, FooTable);\n(function(F){\n\n\t/**\n\t * Adds a row to the underlying {@link FooTable.Rows#all} array.\n\t * @param {(object|FooTable.Row)} dataOrRow - A hash containing the row values or an actual {@link FooTable.Row} object.\n\t * @param {boolean} [redraw=true] - Whether or not to redraw the table, defaults to true but for bulk operations this\n\t * can be set to false and then followed by a call to the {@link FooTable.Table#draw} method.\n\t */\n\tF.Rows.prototype.add = function(dataOrRow, redraw){\n\t\tvar row = dataOrRow;\n\t\tif (F.is.hash(dataOrRow)){\n\t\t\trow = new FooTable.Row(this.ft, this.ft.columns.array, dataOrRow);\n\t\t}\n\t\tif (row instanceof FooTable.Row){\n\t\t\trow.add(redraw);\n\t\t}\n\t};\n\n\t/**\n\t * Updates a row in the underlying {@link FooTable.Rows#all} array.\n\t * @param {(number|FooTable.Row)} indexOrRow - The index to update or the actual {@link FooTable.Row} object.\n\t * @param {object} data - A hash containing the new row values.\n\t * @param {boolean} [redraw=true] - Whether or not to redraw the table, defaults to true but for bulk operations this\n\t * can be set to false and then followed by a call to the {@link FooTable.Table#draw} method.\n\t */\n\tF.Rows.prototype.update = function(indexOrRow, data, redraw){\n\t\tvar len = this.ft.rows.all.length,\n\t\t\trow = indexOrRow;\n\t\tif (F.is.number(indexOrRow) && indexOrRow >= 0 && indexOrRow < len){\n\t\t\trow = this.ft.rows.all[indexOrRow];\n\t\t}\n\t\tif (row instanceof FooTable.Row && F.is.hash(data)){\n\t\t\trow.val(data, redraw);\n\t\t}\n\t};\n\n\t/**\n\t * Deletes a row from the underlying {@link FooTable.Rows#all} array.\n\t * @param {(number|FooTable.Row)} indexOrRow - The index to delete or the actual {@link FooTable.Row} object.\n\t * @param {boolean} [redraw=true] - Whether or not to redraw the table, defaults to true but for bulk operations this\n\t * can be set to false and then followed by a call to the {@link FooTable.Table#draw} method.\n\t */\n\tF.Rows.prototype.delete = function(indexOrRow, redraw){\n\t\tvar len = this.ft.rows.all.length,\n\t\t\trow = indexOrRow;\n\t\tif (F.is.number(indexOrRow) && indexOrRow >= 0 && indexOrRow < len){\n\t\t\trow = this.ft.rows.all[indexOrRow];\n\t\t}\n\t\tif (row instanceof FooTable.Row){\n\t\t\trow.delete(redraw);\n\t\t}\n\t};\n\n})(FooTable);\n\n(function($, F){\n\n\t// global int to use if the table has no ID\n\tvar _uid = 0,\n\t// a hash value for the current url\n\t\t_url_hash = (function(str){\n\t\t\tvar i, l, hval = 0x811c9dc5;\n\t\t\tfor (i = 0, l = str.length; i < l; i++) {\n\t\t\t\thval ^= str.charCodeAt(i);\n\t\t\t\thval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);\n\t\t\t}\n\t\t\treturn hval >>> 0;\n\t\t})(location.origin + location.pathname);\n\n\tF.State = F.Component.extend(/** @lends FooTable.State */{\n\t\t/**\n\t\t * The state component adds the ability for the table to remember its basic state for filtering, paging and sorting.\n\t\t * @constructs\n\t\t * @extends FooTable.Component\n\t\t * @param {FooTable.Table} table - The parent {@link FooTable.Table} object for the component.\n\t\t * @returns {FooTable.State}\n\t\t */\n\t\tconstruct: function(table){\n\t\t\t// call the constructor of the base class\n\t\t\tthis._super(table, table.o.state.enabled);\n\t\t\t// Change this value if an update to this component requires any stored data to be reset\n\t\t\tthis._key = '1';\n\t\t\t/**\n\t\t\t * The key to use to store the state for this table.\n\t\t\t * @type {(null|string)}\n\t\t\t */\n\t\t\tthis.key = this._key + (F.is.string(table.o.state.key) ? table.o.state.key : this._uid());\n\t\t\t/**\n\t\t\t * Whether or not to allow the filtering component to store it's state.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.filtering = F.is.boolean(table.o.state.filtering) ? table.o.state.filtering : true;\n\t\t\t/**\n\t\t\t * Whether or not to allow the paging component to store it's state.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.paging = F.is.boolean(table.o.state.paging) ? table.o.state.paging : true;\n\t\t\t/**\n\t\t\t * Whether or not to allow the sorting component to store it's state.\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tthis.sorting = F.is.boolean(table.o.state.sorting) ? table.o.state.sorting : true;\n\t\t},\n\t\t/* PROTECTED */\n\t\t/**\n\t\t * Checks the supplied data and options for the state component.\n\t\t * @instance\n\t\t * @protected\n\t\t * @param {object} data - The jQuery data object from the parent table.\n\t\t * @fires FooTable.State#\"preinit.ft.state\"\n\t\t * @this FooTable.State\n\t\t */\n\t\tpreinit: function(data){\n\t\t\tvar self = this;\n\t\t\t/**\n\t\t\t * The preinit.ft.state event is raised before the UI is created and provides the tables jQuery data object for additional options parsing.\n\t\t\t * Calling preventDefault on this event will disable the component.\n\t\t\t * @event FooTable.State#\"preinit.ft.state\"\n\t\t\t * @param {jQuery.Event} e - The jQuery.Event object for the event.\n\t\t\t * @param {FooTable.Table} ft - The instance of the plugin raising the event.\n\t\t\t * @param {object} data - The jQuery data object of the table raising the event.\n\t\t\t */\n\t\t\tthis.ft.raise('preinit.ft.state', [data]).then(function(){\n\n\t\t\t\tself.enabled = F.is.boolean(data.state)\n\t\t\t\t\t? data.state\n\t\t\t\t\t: self.enabled;\n\n\t\t\t\tif (!self.enabled) return;\n\n\t\t\t\tself.key = self._key + (F.is.string(data.stateKey) ? data.stateKey : self.key);\n\n\t\t\t\tself.filtering = F.is.boolean(data.stateFiltering) ? data.stateFiltering : self.filtering;\n\n\t\t\t\tself.paging = F.is.boolean(data.statePaging) ? data.statePaging : self.paging;\n\n\t\t\t\tself.sorting = F.is.boolean(data.stateSorting) ? data.stateSorting : self.sorting;\n\n\t\t\t}, function(){\n\t\t\t\tself.enabled = false;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Gets the state value for the specified key for this table.\n\t\t * @instance\n\t\t * @param {string} key - The key to get the value for.\n\t\t * @returns {(*|null)}\n\t\t */\n\t\tget: function(key){\n\t\t\treturn JSON.parse(localStorage.getItem(this.key + ':' + key));\n\t\t},\n\t\t/**\n\t\t * Sets the state value for the specified key for this table.\n\t\t * @instance\n\t\t * @param {string} key - The key to set the value for.\n\t\t * @param {*} data - The value to store for the key. This value must be JSON.stringify friendly.\n\t\t */\n\t\tset: function(key, data){\n\t\t\tlocalStorage.setItem(this.key + ':' + key, JSON.stringify(data));\n\t\t},\n\t\t/**\n\t\t * Clears the state value for the specified key for this table.\n\t\t * @instance\n\t\t * @param {string} key - The key to clear the value for.\n\t\t */\n\t\tremove: function(key){\n\t\t\tlocalStorage.removeItem(this.key + ':' + key);\n\t\t},\n\t\t/**\n\t\t * Executes the {@link FooTable.Component#readState} function on all components.\n\t\t * @instance\n\t\t */\n\t\tread: function(){\n\t\t\tthis.ft.execute(false, true, 'readState');\n\t\t},\n\t\t/**\n\t\t * Executes the {@link FooTable.Component#writeState} function on all components.\n\t\t * @instance\n\t\t */\n\t\twrite: function(){\n\t\t\tthis.ft.execute(false, true, 'writeState');\n\t\t},\n\t\t/**\n\t\t * Executes the {@link FooTable.Component#clearState} function on all components.\n\t\t * @instance\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.ft.execute(false, true, 'clearState');\n\t\t},\n\t\t/**\n\t\t * Generates a unique identifier for the current {@link FooTable.Table} if one is not supplied through the options.\n\t\t * This value is a combination of the url hash and either the element ID or an incremented global int value.\n\t\t * @instance\n\t\t * @returns {*}\n\t\t * @private\n\t\t */\n\t\t_uid: function(){\n\t\t\tvar id = this.ft.$el.attr('id');\n\t\t\treturn _url_hash + '_' + (F.is.string(id) ? id : ++_uid);\n\t\t}\n\t});\n\n\tF.components.register('state', F.State, 700);\n\n})(jQuery, FooTable);\n(function(F){\n\n\t/**\n\t * This method is called from the {@link FooTable.State#read} method and allows a component to retrieve its' stored state.\n\t * @instance\n\t * @protected\n\t * @function\n\t */\n\tF.Component.prototype.readState = function(){};\n\n\t/**\n\t * This method is called from the {@link FooTable.State#write} method and allows a component to write its' current state to the store.\n\t * @instance\n\t * @protected\n\t * @function\n\t */\n\tF.Component.prototype.writeState = function(){};\n\n\t/**\n\t * This method is called from the {@link FooTable.State#clear} method and allows a component to clear any stored state.\n\t * @instance\n\t * @protected\n\t * @function\n\t */\n\tF.Component.prototype.clearState = function(){};\n\n})(FooTable);\n(function(F){\n\n\t/**\n\t * An object containing the state options for the plugin. Added by the {@link FooTable.State} component.\n\t * @type {object}\n\t * @prop {boolean} enabled=false - Whether or not to allow state to be stored for the table. This overrides the individual component enable options.\n\t * @prop {boolean} filtering=true - Whether or not to allow the filtering state to be stored.\n\t * @prop {boolean} paging=true - Whether or not to allow the filtering state to be stored.\n\t * @prop {boolean} sorting=true - Whether or not to allow the filtering state to be stored.\n\t * @prop {string} key=null - The unique key to use to store the table's data.\n\t */\n\tF.Defaults.prototype.state = {\n\t\tenabled: false,\n\t\tfiltering: true,\n\t\tpaging: true,\n\t\tsorting: true,\n\t\tkey: null\n\t};\n\n})(FooTable);\n(function(F){\n\n\tif (!F.Filtering) return;\n\n\t/**\n\t * Allows the filtering component to retrieve its' stored state.\n\t */\n\tF.Filtering.prototype.readState = function(){\n\t\tif (this.ft.state.filtering){\n\t\t\tvar state = this.ft.state.get('filtering');\n\t\t\tif (F.is.hash(state) && !F.is.emptyArray(state.filters)){\n\t\t\t\tthis.filters = this.ensure(state.filters);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Allows the filtering component to write its' current state to the store.\n\t */\n\tF.Filtering.prototype.writeState = function(){\n\t\tif (this.ft.state.filtering) {\n\t\t\tvar filters = F.arr.map(this.filters, function (f) {\n\t\t\t\treturn {\n\t\t\t\t\tname: f.name,\n\t\t\t\t\tquery: f.query instanceof F.Query ? f.query.val() : f.query,\n\t\t\t\t\tcolumns: F.arr.map(f.columns, function (c) {\n\t\t\t\t\t\treturn c.name;\n\t\t\t\t\t}),\n\t\t\t\t\thidden: f.hidden,\n\t\t\t\t\tspace: f.space,\n\t\t\t\t\tconnectors: f.connectors,\n\t\t\t\t\tignoreCase: f.ignoreCase\n\t\t\t\t};\n\t\t\t});\n\t\t\tthis.ft.state.set('filtering', {filters: filters});\n\t\t}\n\t};\n\n\t/**\n\t * Allows the filtering component to clear any stored state.\n\t */\n\tF.Filtering.prototype.clearState = function(){\n\t\tif (this.ft.state.filtering) {\n\t\t\tthis.ft.state.remove('filtering');\n\t\t}\n\t};\n\n})(FooTable);\n(function(F){\n\n\tif (!F.Paging) return;\n\n\t/**\n\t * Allows the paging component to retrieve its' stored state.\n\t */\n\tF.Paging.prototype.readState = function(){\n\t\tif (this.ft.state.paging) {\n\t\t\tvar state = this.ft.state.get('paging');\n\t\t\tif (F.is.hash(state)) {\n\t\t\t\tthis.current = state.current;\n\t\t\t\tthis.size = state.size;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Allows the paging component to write its' current state to the store.\n\t */\n\tF.Paging.prototype.writeState = function(){\n\t\tif (this.ft.state.paging) {\n\t\t\tthis.ft.state.set('paging', {\n\t\t\t\tcurrent: this.current,\n\t\t\t\tsize: this.size\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Allows the paging component to clear any stored state.\n\t */\n\tF.Paging.prototype.clearState = function(){\n\t\tif (this.ft.state.paging) {\n\t\t\tthis.ft.state.remove('paging');\n\t\t}\n\t};\n\n})(FooTable);\n(function(F){\n\n\tif (!F.Sorting) return;\n\n\t/**\n\t * Allows the sorting component to retrieve its' stored state.\n\t */\n\tF.Sorting.prototype.readState = function(){\n\t\tif (this.ft.state.sorting) {\n\t\t\tvar state = this.ft.state.get('sorting');\n\t\t\tif (F.is.hash(state)) {\n\t\t\t\tvar column = this.ft.columns.get(state.column);\n\t\t\t\tif (column instanceof F.Column) {\n\t\t\t\t\tthis.column = column;\n\t\t\t\t\tthis.column.direction = state.direction;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Allows the sorting component to write its' current state to the store.\n\t */\n\tF.Sorting.prototype.writeState = function(){\n\t\tif (this.ft.state.sorting && this.column instanceof F.Column){\n\t\t\tthis.ft.state.set('sorting', {\n\t\t\t\tcolumn: this.column.name,\n\t\t\t\tdirection: this.column.direction\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Allows the sorting component to clear any stored state.\n\t */\n\tF.Sorting.prototype.clearState = function(){\n\t\tif (this.ft.state.sorting) {\n\t\t\tthis.ft.state.remove('sorting');\n\t\t}\n\t};\n\n})(FooTable);\n(function(F){\n\n\t// hook into the _construct method so we can add the state property to the table.\n\tF.Table.extend('_construct', function(ready){\n\t\tthis.state = this.use(FooTable.State);\n\t\treturn this._super(ready);\n\t});\n\n\t// hook into the _preinit method so we can trigger a plugin wide read state operation.\n\tF.Table.extend('_preinit', function(){\n\t\tvar self = this;\n\t\treturn self._super().then(function(){\n\t\t\tif (self.state.enabled){\n\t\t\t\tself.state.read();\n\t\t\t}\n\t\t});\n\t});\n\n\t// hook into the draw method so we can trigger a plugin wide write state operation.\n\tF.Table.extend('draw', function(){\n\t\tvar self = this;\n\t\treturn self._super().then(function(){\n\t\t\tif (self.state.enabled){\n\t\t\t\tself.state.write();\n\t\t\t}\n\t\t});\n\t});\n\n})(FooTable);\n(function($, F){\n\n\tF.Export = F.Component.extend(/** @lends FooTable.Export */{\n\t\t/**\n\t\t * @summary This component provides some basic export functionality.\n\t\t * @memberof FooTable\n\t\t * @constructs Export\n\t\t * @param {FooTable.Table} table - The current instance of the plugin.\n\t\t */\n\t\tconstruct: function(table){\n\t\t\t// call the constructor of the base class\n\t\t\tthis._super(table, true);\n\t\t\t/**\n\t\t\t * @summary A snapshot of the working set of rows prior to being trimmed by the paging component.\n\t\t\t * @memberof FooTable.Export#\n\t\t\t * @name snapshot\n\t\t\t * @type {FooTable.Row[]}\n\t\t\t */\n\t\t\tthis.snapshot = [];\n\t\t},\n\t\t/**\n\t\t * @summary Hooks into the predraw pipeline after sorting and filtering have taken place but prior to paging.\n\t\t * @memberof FooTable.Export#\n\t\t * @function predraw\n\t\t * @description This method allows us to take a snapshot of the working set of rows before they are trimmed by the paging component and is called by the plugin instance.\n\t\t */\n\t\tpredraw: function(){\n\t\t\tthis.snapshot = this.ft.rows.array.slice(0);\n\t\t},\n\t\t/**\n\t\t * @summary Return the columns as simple JavaScript objects in an array.\n\t\t * @memberof FooTable.Export#\n\t\t * @function columns\n\t\t * @returns {Object[]}\n\t\t */\n\t\tcolumns: function(){\n\t\t\tvar result = [];\n\t\t\tF.arr.each(this.ft.columns.array, function(column){\n\t\t\t\tif (!column.internal){\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\ttype: column.type,\n\t\t\t\t\t\tname: column.name,\n\t\t\t\t\t\ttitle: column.title,\n\t\t\t\t\t\tvisible: column.visible,\n\t\t\t\t\t\thidden: column.hidden,\n\t\t\t\t\t\tclasses: column.classes,\n\t\t\t\t\t\tstyle: column.style\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * @summary Return the rows as simple JavaScript objects in an array.\n\t\t * @memberof FooTable.Export#\n\t\t * @function rows\n\t\t * @param {boolean} [filtered=false] - Whether or not to exclude filtered rows from the result.\n\t\t * @returns {Object[]}\n\t\t */\n\t\trows: function(filtered){\n\t\t\tfiltered = F.is.boolean(filtered) ? filtered : false;\n\t\t\tvar rows = filtered ? this.ft.rows.all : this.snapshot, result = [];\n\t\t\tF.arr.each(rows, function(row){\n\t\t\t\tresult.push(row.val());\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * @summary Return the columns and rows as a properly formatted JSON object.\n\t\t * @memberof FooTable.Export#\n\t\t * @function json\n\t\t * @param {boolean} [filtered=false] - Whether or not to exclude filtered rows from the result.\n\t\t * @returns {Object}\n\t\t */\n\t\tjson: function(filtered){\n\t\t\treturn JSON.parse(JSON.stringify({columns: this.columns(),rows: this.rows(filtered)}));\n\t\t},\n\t\t/**\n\t\t * @summary Return the columns and rows as a properly formatted CSV value.\n\t\t * @memberof FooTable.Export#\n\t\t * @function csv\n\t\t * @param {boolean} [filtered=false] - Whether or not to exclude filtered rows from the result.\n\t\t * @returns {string}\n\t\t */\n\t\tcsv: function(filtered){\n\t\t\tvar csv = \"\", columns = this.columns(), value, escaped;\n\t\t\tF.arr.each(columns, function(column, i){\n\t\t\t\tescaped = '\"' + column.title.replace(/\"/g, '\"\"') + '\"';\n\t\t\t\tcsv += (i === 0 ? escaped : \",\" + escaped);\n\t\t\t});\n\t\t\tcsv += \"\\n\";\n\n\t\t\tvar rows = filtered ? this.ft.rows.all : this.snapshot;\n\t\t\tF.arr.each(rows, function(row){\n\t\t\t\tF.arr.each(row.cells, function(cell, i){\n\t\t\t\t\tif (!cell.column.internal){\n\t\t\t\t\t\tvalue = cell.column.stringify.call(cell.column, cell.value, cell.ft.o, cell.row.value);\n\t\t\t\t\t\tescaped = '\"' + value.replace(/\"/g, '\"\"') + '\"';\n\t\t\t\t\t\tcsv += (i === 0 ? escaped : \",\" + escaped);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tcsv += \"\\n\";\n\t\t\t});\n\t\t\treturn csv;\n\t\t}\n\t});\n\n\t// register the component using a priority of 490 which falls just after filtering (500) and before paging (400).\n\tF.components.register(\"export\", F.Export, 490);\n\n})(jQuery, FooTable);\n(function(F){\n\t// this is used to define the filtering specific properties on column creation\n\tF.Column.prototype.__export_define__ = function(definition){\n\t\tthis.stringify = F.checkFnValue(this, definition.stringify, this.stringify);\n\t};\n\n\t// overrides the public define method and replaces it with our own\n\tF.Column.extend('define', function(definition){\n\t\tthis._super(definition); // call the base so we don't have to redefine any previously set properties\n\t\tthis.__export_define__(definition); // then call our own\n\t});\n\n\t/**\n\t * @summary Return the supplied value as a string.\n\t * @memberof FooTable.Column#\n\t * @function stringify\n\t * @returns {string}\n\t */\n\tF.Column.prototype.stringify = function(value, options, rowData){\n\t\treturn value + \"\";\n\t};\n\n\tif (F.is.defined(F.DateColumn)){\n\t\t// override the base method for DateColumns\n\t\tF.DateColumn.prototype.stringify = function(value, options, rowData){\n\t\t\treturn F.is.object(value) && F.is.boolean(value._isAMomentObject) && value.isValid() ? value.format(this.formatString) : '';\n\t\t};\n\t}\n\n\t// override the base method for ObjectColumns\n\tF.ObjectColumn.prototype.stringify = function(value, options, rowData){\n\t\treturn F.is.object(value) ? JSON.stringify(value) : \"\";\n\t};\n\n\t// override the base method for ArrayColumns\n\tF.ArrayColumn.prototype.stringify = function(value, options, rowData){\n\t\treturn F.is.array(value) ? JSON.stringify(value) : \"\";\n\t};\n\n})(FooTable);\n(function(F){\n\t/**\n\t * @summary Return the columns and rows as a properly formatted JSON object.\n\t * @memberof FooTable.Table#\n\t * @function toJSON\n\t * @param {boolean} [filtered=false] - Whether or not to exclude filtered rows from the result.\n\t * @returns {Object}\n\t */\n\tF.Table.prototype.toJSON = function(filtered){\n\t\treturn this.use(F.Export).json(filtered);\n\t};\n\n\t/**\n\t * @summary Return the columns and rows as a properly formatted CSV value.\n\t * @memberof FooTable.Table#\n\t * @function toCSV\n\t * @param {boolean} [filtered=false] - Whether or not to exclude filtered rows from the result.\n\t * @returns {string}\n\t */\n\tF.Table.prototype.toCSV = function(filtered){\n\t\treturn this.use(F.Export).csv(filtered);\n\t};\n\n})(FooTable);\n\n\n//# sourceURL=webpack:///./js/footable.js?");

/***/ })

/******/ });